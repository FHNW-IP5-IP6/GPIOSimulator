:toc: left
:toc-title:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:sourcedir: ../src/main/java
:imagesdir: ./assets/images
:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/FHNW-IP5-IP6/GPIOSimulator

image::FHNW.png[FHNW,382,59]
[discrete]
= IP5: FHNW Pi4J Tutorial

*Autoren*:

* Herr Jonathan Bättig (jonathan.baettig@students.fhnw.ch) 
* Herr Anessollah Ima (anessollah.ima@students.fhnw.ch)

*FHNW* +
*Hochschule für Technik* +
*Studiengang* : Informatik +
*Semester* : 6BB

*Betreuende Dozenten*:

* Frau Dr. Barbara Scheuner (barbara.scheuner@fhnw.ch) 
* Herr Dr. Dieter Holz (dieter.holz@fhnw.ch) 

*Datum*: {docdate}

<<<
[discrete]
== Inhaltsverzeichnis
toc::[]

<<<
:sectnums!:
== TODO Einleitung
:sectnums:

<<<

== Hardware 

=== Raspberry Pi

=== Grove Sensoren & Aktuatoren

=== Grove Base Hat
Grove Sensoren und Aktuatoren sind beliebt und werden oft in Projekten eingesetzt. Sie verfügen über simple Steckverbindungen, sogenannte Adapter, welche in Kombination mit dem Grove Base Hat eine sichere und fehlerfreie Verbindung mit dem Raspberry Pi garantieren.

.Grove Base Hat
image::Grove_Base_Hat.png[500, 500, Grove Base Hat]

Der Grove Base Hat stellt Adapter für PWM, Digital, Analog, UART sowie I2C zur Verfügung. Zusätzlich werden alle GPIO Pins auf den Hat projiziert. Unsere Implementation des Grove Adapters unterstützt alle diese Anschlüsse.

[source,java]
----
include::{sourcedir}\fhnwgpio\grove\GroveAdapter.java[tags=GroveAdapter]
----

Die Sensoren und Aktuatoren können über unsere Implementation sehr einfach verwendet werden. Das untere Beispiel zeigt, wie ein Potentiometer, welcher am Grove Base Hat Adapter A0 angeschlossen ist, erzeugt und abgefragt werden kann.

[source,java]
----
PotentiometerComponent potentiometer = new PotentiometerComponent(GroveAdapter.A0);
potentiometer.getValue()
----

==== PWM
Der Grove Base Hat unterstütz die Hardware PWM Pins 12 sowie 13. Beide Pins sind im selben Adapter vereinigt.

==== UART
Der UART Adapter macht den Serial Bus der Raspberry Pi für Grove Sensoren und Aktuatoren verfügbar. Er benutzt die GPIO Pins 14 und 15. An diesem Port würden wir die Grove Serial Camera anschliessen, wenn diese mit 3.3 Volt kompatibel wäre.

==== Digital
Der Grove Base Hat stellt sechs digitale Adapter zur Verfügung. Die Adapter stellen die Standard GPIO Pins des Pi dar. Die Pin Nummern entsprechen den Zahlen auf dem Board. Beispielsweise entspricht der Adapter D22 den Pins 22 und 23.

==== Analog
Der Raspberry Pi selbst besitzt nur digitale GPIO Pins. Hier stellt uns der Grove Base Hat also zusätzliche Funktionalität zur Verfügung. An die vier analogen Adapter können analoge Sensoren und Aktuatoren angeschlossen werden. Diese kommunizieren mit einem Chip, welcher sich auf der Rückseite des Hats befindet. Dieser Chip wandelt dann die analogen Daten in ein digitales Format um. Zusätzlich implementiert der Chip das I2C Interface, über welches er mit dem Pi kommunizieren kann.

Der Chip hat die I2C Adresse 0x04. Die einzelnen analogen Anschlüsse haben jeweils eine eigene Device Adresse.

* **A0**: 0x30
* **A2**: 0x32
* **A4**: 0x34
* **A6**: 0x36

==== I2C
Die drei I2C Anschlüsse sind alle mit dem I2C Bus 1 des Raspberry Pi verbunden. Mit I2C können mehrere Devices auf einmal angesteuert werden.

=== Breadboard


=== Software

==== Pi4J

==== Java

== Setup des RaspberryPi
Bevor Sie mit der Implementation ihres ersten Raspberry Pi Projekts starten können, muss der Mini-Computer aufgesetzt werden. Im Gegensatz zu den verschiedenen im Handel erhältichen Micro Controllern, wie Beispielsweise der Arduino Uno, benötigt der Pi ein Betriebssystem. Wir verwenden das auf Linux basierende System Raspbian, eine speziell für den Raspberry Pi modifiziertes Derbian.

=== Vorbereitung der Mini SD-Karte
Wie bereits erwähnt, verwenden wir für den Betrieb des Raspberry Pi das Linux OS Raspbian. Das Betriebssystem werden Sie später auf die Ihnen zur Verfügung gestellte Mini SD-Karte installieren.

In einem ersten Schritt laden Sie bitte das Raspbian Image aus dem Internet auf Ihren Rechner und speichern die Datei ab. Besuchen Sie hierfür die Download-Website der Raspberry Organisation: + 
https://www.raspberrypi.org/downloads/raspbian/

._Raspbian Download_
image::./installation/raspbianDownload.png[width=75% raspbian Download]

Wählen Sie nun die Raspbian Version `Raspbian Buster with desktop` aus. Sobald Ihr Browser den Download abgeschlossen hat, extrahieren Sie bitte den Zip-Ordner an eine beliebige Stelle. Im extrahierten Ordner befindet sich eine .img-Datei, welche wir in den folgenden Installationsschritten benötigen werden. Merken Sie sich also, wo auf dem Dateisystem der entpackte Folder liegt.

Damit Sie das Raspbian Image auf Ihre SD-Karte installieren können, brauchen Sie eine geeignete Disk Imaging Software. Wir empfehlen Ihnen dafür balenaEtcher zu verwenden. Es gibt aber auch andere dafür geeignete Programme.

Wenn Sie sich ebenfalls für balenaEtcher entscheiden, können Sie das Programm über den folgenden Link direkt von der balena Webseite herunterladen und installieren: + 
https://www.balena.io/etcher/

._balenaEtcher Download_
image::./installation/balenaDownload.png[width=75% balenaEtcher Download]

Nachdem Sie balenaEtcher installiert haben, können Sie die Applikation starten. In nur drei einfachen Schritten spiegelt balenaEtcher das Raspbian Image auf Ihre Mini SD-Karte.

._balenaEtcher Startbildschirm_
image::./installation/balenaStart.png[width=75% balenaEtcher Startbildschirm]

. Wählen Sie in einem ersten Schritt die .img-Datei des zuvor heruntergeladenen Raspbian aus.
. Wählen Sie nun die Mini SD-Karte aus, welche Sie an Ihren PC angeschlossen haben. Bitte beachten Sie, dass die SD-Karte während der Installation formatiert wird und somit alle sich auf der Karte befindenden Daten unwiederruflich gelöscht werden.
. Klicken Sie auf "Flash!" um die Installation des Images zu starten. Dieser Prozess kann einige Minuten in Anspruch nehmen.

Sobald der Flash Vorgang abgeschlossen wurde, ist Raspbian auf der SD-Karte installiert und das OS ist betriebsbereit.

=== Raspberry Pi mit zusätzlicher Hardware nutzen
Wenn Sie den Raspberry Pi als normalen Desktop Rechner verwenden möchten, können Sie die vorbereitete Mini SD-Karte in den Pi einsetzen und weitere Hardware wie Maus, Monitor und Tastatur direkt an Ihren Pi anschliessen. Sobald Sie den Computer an das Stromnetz anschliessen, fährt Raspbian hoch und eine Login Maske erscheint.

Für das initiale Login auf dem Pi können Sie die folgenden Standard Credentials verwenden:

* *User*: pi
* *Passwort*: raspberry

=== Raspberry Pi ohne zusätzliche Hardware nutzen
Es gibt verschiedene Gründe, weshalb Sie den Raspberry Pi ohne zusätzliche Hardware verwenden möchten. Womöglich erfüllt der Pi die Mindestanforderungen Ihrer bevorzugten Entwicklungsumgebung nicht oder Ihnen steht schlicht und einfach nicht die nötige Hardware zur Verfügung. In diesem Kapitel möchten wir Ihnen aufzeigen, wie Sie den Mini Computer ganz ohne zusätzliche Hardware konfigurieren und verwenden können. Sie benötigen dazu ledeglich ein USB-Kabel und Ihren Laptop.

Um mit dem Raspberry Pi ohne zusätzliche Hardware arbeiten zu können, wird SSH verwendet. Damit Sie via SSH auf den Pi zugreifen können, benötigen Sie eine SSH Software. Ein beliebtes Tool ist PuTTY. Sie können es unter folgendem Link direkt vom Hersteller herunterladen und auf Ihrem Rechner installieren: +
https://www.putty.org/

==== Zugriff über SSH
Bevor Sie sich mit PuTTY via SSH auf den Pi einloggen können, müssen Sie SSH in Raspbian aktivieren. Dazu legen Sie die SD-Karte erneut in Ihren PC ein und navigieren anschliessend mittels Datei-Explorer in den `boot` Folder der SD-Karte.

Jetzt müssen Sie verschiedene Einstellungen direkt an den markierten Files im `boot` Ordner vornehmen:

._boot Ordner_
image::./installation/bootFolder.png[width=75% boot Ordner]

* Im File `config.txt` müssen Sie ganz am Schluss den folgenden Snippet hinzufügen: +
[source]
----
dtoverlay=dwc2
----

* Im File `cmdline.txt` müssen Sie nach dem Text "rootwait" suchen und danach den folgenden Snippet hinzufügen: +
[source]
----
modules-load=dwc2,g_ether
----

Der relevante Ausschnitt des Files sieht dann zum Beispiel so aus: 

._cmdLine File_
image::./installation/cmdLine.png[width=75% cmdLine file]

Zu guter Letzt erstellen Sie ein leeres File ohne Dateiendung mit dem Namen `ssh`. Um dies zu erreichen, können Sie beispielsweise ein neues Textfile erstellen und dieses `ssh` nennen. Nun entfernen Sie die Dateiendung .txt.

._SSH aktivieren_
image::./installation/activateSSH.png[width=75% activate SSH]

Nun können Sie die Mini SD-Karte wieder in den Raspberry Pi einlegen und diesen mittels USB-Kabel an Ihren Computer anschliessen. Beim Startup von Raspbian untersucht das System den boot Folder und lädt Ihre neuen Einstellungen. Anschliessend können Sie PuTTY starten und mit der folgenden Konfiguration auf den Pi zugreifen.

._SSH Zugriff mit PuTTY_
image::./installation/SSHputty.png[width=65% SSH Zugriff]

Im neuen Shell Fenster können Sie sich mit den Standard Credentials anmelden und den Raspberry Pi über die Konsole verwenden.

* *User*: pi
* *Passwort*: raspberry

._Login in PuTTY_
image::./installation/puttyLogin.png[width=75% Login in PuTTY]


==== Zugriff über WiFi
Die Verbindung zum Raspberry Pi via SSH funktioniert auch kabellos. Dafür muss sich Ihr Computer lediglich im gleichen Netzwerk befinden wie der Raspberry Pi. Zum Beispiel bei Ihnen Zuhause im WLAN oder über Ihren mobilen HotSpot. Damit der Pi auf das WLAN zugreifen kann, müssen Sie die SD-Karte erneut an Ihren Laptop anschliessen und eine neue Datei im boot Ordner erstellen. Das `wpa_supplicant.conf` File.

Wenn Sie bereits mit dem Pi über Kabel verbunden sind, können Sie die Datei auch direkt über die PuTTY Konsole erstellen. Mit dem unteren Befehl wird das File mit dem Text Editor `nano` erstellt.

[source]
----
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
----

[source]
----
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=CH

network={
    ssid="NETZWERK"
    psk="PASSWORT"
}
----

Bei `ssid` müssen Sie Ihren Netzwerknamen angeben und bei `psk` das Passwort. Sobald Sie die nötigen Einstellungen abgeschlossen haben, speichern Sie die getätigten Änderungen. Sofern nötig, schliessen Sie die SD-Karte wieder an den Raspberry Pi an.

Jetzt können Sie in PuTTY die IP-Adresse Ihres Raspberry Pi eingeben und sich somit direkt über das WLAN mit ihm verbinden.

Die IP Adresse Ihres Raspberry Pi können Sie über den Befehl `hostname -I` anzeigen lassen, sofern Sie bereits über Kabel mit dem Pi verbunden sind. Alternativ können Sie auch ein Tool auf Ihrem Laptop installieren, welches Ihr Netzwerk nach IPs scannt. Dafür haben wir den Advanced IP Scanner verwendet. Er ist einfach zu verwenden und seine Funktionalität ist selbsterklärend. Das Tool kann unter dem folgenden Link für Windows Rechner heruntergeladen werden: +
https://www.advanced-ip-scanner.com/de/

._Advanced IP Scanner_
image::./installation/advanced_ip_scanner.png[width=75% Advanced IP Scanner]

==== Zugriff auf UI via VNC Viewer
Um ohne Monitor von den Vorzügen des grafischen User Interface von Raspbian profitieren zu können, kann man die VNC Funktionalitäten des Raspberry Pi verwenden. Dieses Feature muss allerdings zuerst in den Einstellungen des Raspberry Pi aktiviert werden.

. Die Raspberry Pi Konfiguration mit dem Befehl `sudo raspi-config` öffnen.
. Unter `Interfacing Options` zu `VNC` navigieren und die Auswahl bestätigen.

Der Pi ist nun für die Verwendung von VNC konfiguriert. Jetzt müssen Sie noch ein entsprechendes Tool auf Ihrem Rechner installieren. Wir haben mit der Software Real VNC Viewer gute Erfahrungen gemacht und würden Ihnen ebenfalls empfehlen, dieses Tool zu verwenden. Es untersützt eine breite Palette von Betriebssystemen, auf welchen es installiert werden kann. Das Tool kann über diese Webseite bezogen werden: + 
https://www.realvnc.com/de/connect/download/viewer/

Beim Startup des Tools muss zuerst eine neue Verbindung angegeben werden. Diese wird dann für die künftige Verwendung abgespeichert.

._VNC Viewer Zugriff auf Pi_
image::./installation/VNCViewer.png[width=70% VNC Viewer Zugriff auf Pi]

Nach einem kurzen Verbindungsaufbau öffnet sich ein neues Fenster, welches einem den Remote Zugriff auf das User Interface des Raspberry Pi erlaubt.

._VNC Viewer GUI von Raspbian_
image::./installation/VNCViewerGUI.png[width=70% VNC Viewer GUI von Raspbian]

Es kann gut sein, dass die Auflösung sowie die Grösse der Icons zu Beginn noch nicht optimal ist. Die Einstellungen können Sie wie folgend anpassen:

* *Auflösung*: + 
    _Preferences -> Raspberry Pi Configuration -> Display_ +
    Hier können Sie unter "Set Resolution" die Auflösung verändern. Es kann sein, dass Sie zusätzlich die Option _"Underscan"_ deaktivieren müssen, weil sie eventuell Ihre Einstellungen zur Auflösung überschreibt.

* *Icon Grösse*: + 
    _Preferences -> Appearance Settings -> System -> Defaults_ + 
    Hier können Sie die Grösse der Icons gemäss Ihren Präferenzen ändern.

=== TODO: Installation von zusätzlicher Software auf dem Pi

==== Java

==== Git

==== Gradle

== TODO: Code auf dem Pi bauen
Es ist möglich den Code in intelliJ auf dem eigenen Rechner zu schreiben und diesen dann auf den Pi zu deployen. Da hat den wesentlichen Vorteil, dass man nicht mit der langsamen Entwicklungsumgebung des Raspberry Pi arbeiten muss und auch nicht jede kleinste Änderung in git pushen muss, nur um kleine Veränderungen in er Hardware auf dem Pi auszuprobieren.

=== Remote Host in IntelliJ
Um Ihren Raspberry Pi als Remote Host einzurichten in IntelliJ, müssen Sie zuerst in der Menüleiste auf _"Tools" -> "Deployment" -> "Browse Remote Host"_

._Remote Host Setting_
image::./installation/RemoteHost.png[width=75% remote host setting]

Jetzt escheint ein neues Menü auf der rechten Seite, wo sich auch normalerweise auch die gradle und database Einstellungen befinden. 

Klicken Sie in diesem Menü auf die 3 Punkte, um einen neuen Server zu erstellen. Der Name spielt keine Rolle, aber der Typ sollte SFTP sein. Bestätigen Sie dann ihre Eingabe.

._Remote Host Server hinzufügen_
image::./installation/RemoteHost2.png[width=75% add remote host server]

Nun können Sie die Einstellung für ihren Raspberry Pi im Deployment Fenster angeben:

. Geben Sie zuerst die IP-Adresse des Raspberry Pis an

. Hier können Sie die Connection mit dem Usernamen und dem Passwort einmal ausprobieren, bevor Sie es hinzufügen.

. Nach dem Connection-Test können Sie auf das kleine Ordner Symbol klicken, um auf die Ordner Struktur des Raspberry Pis zu zugreifen. Wählen Sie hier den Ort, an dem Alle Files des Projekts hinkopiert werden sollen.

. Sie können mehrere Server hinzufügen, für die einfache Verwendung in verschiedenen Netzwerken



._Remote Host Server Einstellungen_
image::./installation/RemoteHost3.png[width=75% remote host server settings]

Jetzt können Sie jeder Zeit alle Files oder einzelne ausgewählte mit dem Menü auf der Rechten Seite auf den Raspberry Pi übertragen.

._Update Remote Host_
image::./installation/RemoteHost4.png[width=75% update remote host server]


== Beispiele
In diesem Kapitel finden Sie für eine Vielzahl an gängigen Sensoren und Aktuatoren Code Beispiele sowie Beispiele zur Verkabelung. Für ein vollständiges Verständnis der Code Beispiele sind gewisse Vorkenntnisse von Nöten. Wir haben die Beispiele deshalb in Levels eingeteilt, an welchen Sie den Grad an nötigen Vorkenntnissen einfach erkennen können.

* *Level 1: Basic*
    ** Variablen und Berechnungen: primitive Datentypen, Wertebereiche und deren Auswirkung beim Rechnen.
    ** Methoden und Parameter: Deklaration, Aufruf, Signatur, Argumente und Rückgabewerte.
    ** Kontrollstrukturen: Schleifen und Fallunterscheidungen.
    ** Grundlagen Klassen, Objekte und Vererbung: Deklaration und Instanziierung von Klassen, Überladen und Überschreiben von Methoden, Vererbung, Polymorphie.
* *Level 2: Intermediate*
    ** Verwendung grundlegender Datenstrukturen (List, Map, Set) und Iteratoren.
    ** Generics und ihre Besonderheiten in Java.
    ** Event Handling.
    ** Collection-Streams und Lambda-Ausdrücke.
* *Level 3: Advanced*
    ** Nebenläufigkeit mit Threads.
    ** Strukturierung von Applikationen.
    ** Daten-Persistenz (File-Handling, Serialisierung).

=== Blink LED
==== Verkabelung

Für die Verkabelung wird folgende Hardware benötigt:

* 2x Kabel
* 1x LED
* 1x 220Ω Wiederstand

.LED Verkabelung 
image::./fritzing/blink_led.png[width=75% LED Wiring]

==== Code Beispiel
Die blinkende LED ist das "Hello World"-Äquivalent der GPIO Programmierung. Mit dem nachfolgenden Code lassen wir eine LED im Abstand von einer Sekunde blinken.

===== GPIO Beispiel
*Vorkenntnisse: Basic*
[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/BlinkLed.java[tags=BlinkLed]
----
===== Device Beispiel
*Vorkenntnisse: Advanced*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/BlinkLedDevice.java[tags=BlinkLedDevice]
----

=== Button Click
==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 4x Kabel
* 1x Button
* 1x 220Ω Wiederstand

.Button Verkabelung 
image::./fritzing/button_click.png[width=75% Button Wiring]

==== Code Beispiel
In diesem Beispiel wird jeder Klick auf dem Button in der Konsole angezeigt.

===== GPIO Beispiel
*Vorkenntnisse: Basic*
[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/ButtonClick.java[tags=ButtonClick]
----

===== Device Beispiel
*Vorkenntnisse: Intermediate*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/ButtonClickDevice.java[tags=ButtonClickDevice]
----

=== LCD
=== LCD I2C
==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 4x Kabel
* 1x LCD1602 I2C Modul mit PCF8574 I2C extender

.LCD I2C Modul Verkabelung 
image::./fritzing/LCDI2C.png[width=75% I2C Wiring]

==== Code Beispiel

In diesem Code Beispiel wird der Titel des Projekts in der ersten Zeile angezeigt und die Uhrzeit in der Zweiten. Die Uhrzeit wird im Sekundentakt aktualisiert. +
*Vorkenntnisse: Basic*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/LcdSystemTimeI2C.java[tags=LcdSystemTimeI2C]
----

=== Motor Direction

=== Motor Hardware PWM

=== Motor Software PWM

=== Potentiometer
Ein Potentiometer ist eine Art dynamischer Wiederstand, welcher durch das Drehen oder Verschieben eines Reglers vergrössert oder verkleinert werden kann. Der Grove Potentiometer gibt uns je nach eingestelltem Wiederstand einen Wert zwischen 0 und 1'000 zurück. Mit einem Potentiometer können wir also Werte einstellen, mit welchen wir dann einen Aktuator kontrollieren können. Zum Beispiel könnten wir mit einem Potentiometer die Helligkeit einer Leuchtdiode steuern.

.Grove Potentiometer
image::./Grove_Rotary_Angle_Sensor.jpg[width=75% Grove Rotary Angle Sensor]

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Grove Potentiometer mit Grove Adapter Kabel

.Grove Potentiometer Verkabelung
image::./fritzing/Grove_Base_Hat_Rotary_Angel_Sensor.jpg[width=75% Grove Rotary Angle Sensor Fritzing]

==== API
.Potentiometer - Konstruktoren
[cols="1,1"]
|===
|Konstruktor |Beschreibung
|PotentiometerComponent(GroveAdapter groveAdapter) |Constructor of the PotentiometerComponent with Grove adapter.
|===

.Potentiometer - Funktionen
[cols="1,2,2"]
|===
|Rückgabetyp |Funktion |Beschreibung
|int |getValue() |Get the current value from the potentiometer.
|void |setRange(int minValue, int maxValue) |Set the value returned by getValue() to a specific range. The difference between minValue and MaxValue must be between 10 and 999.
|===

==== Anwendungsbeispiel
Das Code Beispiel erzeugt ein neues `PotentiometerComponent`, welches am Grove Base Hat am analogen Adapter A0 anliegt. Mit der `setRange()` Funktion wird sichergestellt, dass die zurückgegebenen Werte zwischen 0 und 100 liegen. Der aktuelle Wert wird alle 500 Millisekunden geloggt.

[source,java]
----
include::{sourcedir}/fhnwexamples/component/PotentiometerDevice.java[tags=PotentiometerDevice]
----


=== Serial Camera
Die Grove Serial Camera besteht aus einem Kamera Modul und einem Control Board, welches die Kommunikation zwischen der Kamera und dem Raspberry Pi über den Serial Bus ermöglicht. Die Kamera benötigt eine Spannung von 5 Volt, weshalb sie leider nicht mit unserem Grove Hat kompatibel ist. Dieser liefert nur 3.3 Volt an die Grove Adapter. Um die Kamera dennoch nutzen zu können, muss sie via Jumper Kabel an den Serial Port des Raspberry Pi angeschlossen werden. Weitere Informationen zur Verkabelung können dem Tutorial entnommen werden.

.Grove Serial Camera
image::Grove_Serial_Camera.jpg[width=75% Grove Serial Camera]

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Grove Serial Camera mit Grove Adapter Kabel
* 4x Kabel

.Serial Camera Verkabelung
image::./fritzing/grove_serial_cam.png[width=75% Grove Serial Camera Fritzing]

==== API
.Serial Camera - Konstruktoren
[cols="1,1"]
|===
|Konstruktor |Beschreibung
|SerialCameraComponent(com.pi4j.util.Console console) |Constructor of the SerialCameraComponent without logging and a default package size of 512 bytes.
|SerialCameraComponent(com.pi4j.util.Console console, boolean activateLogging) |Constructor of the SerialCameraComponent with a default package size of 512 bytes.
|SerialCameraComponent(com.pi4j.util.Console console, int packageSize) |Constructor of the SerialCameraComponent without logging.
|SerialCameraComponent(com.pi4j.util.Console console, int packageSize, boolean activateLogging) |Constructor of the SerialCameraComponent.
|===

.Serial Camera - Funktionen
[cols="1,2,2"]
|===
|Rückgabetyp |Funktion |Beschreibung
|byte[] |getImageAsJpgBytes() |This method request a jpg image of the camera and returns it as a byte array.
|java.lang.String |saveImageAsJpg(java.lang.String fileName) | Requests a jpg image from the camera and streams it to a file.
|java.lang.String |saveImageAsJpg(java.lang.String relativePath, java.lang.String fileName) |Requests a jpg image from the camera and streams it to a file.
|===

==== Anwendungsbeispiel
Das unten abgebildete Code Beispiel zeigt, wie mit der Hilfe unserer SerialCameraComponent ein JPEG Foto geschossen und unter einem bestimmten Pfad abgespeichert werden kann.

[source,java]
----
include::{sourcedir}/fhnwexamples/component/SerialCamera.java[tags=SerialCamera]
----

=== Raspberry Pi Camera

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Raspberry Pi Camera mit Flachbandkabel

.Raspberry Pi Camera Verkabelung 
image::./fritzing/raspiCam.png[width=60% RaspiCam Wiring]

==== Code Beispiel
In diesem Code Beispiel wird die Raspberry Pi Camera mit einer externen Library verwendet. Es werden 10 Bilder nacheinander geschossen und in den Ordner `/home/pi/Pictures/PiCamPics` gespeichert.  +
*Vorkenntnisse: Intermediate*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/RaspberryPiCamera.java[tags=RaspberryPiCamera]
----


=== Servo Motor

=== Stepper Motor

== Zusatzinformationen

=== Grove Serial Camera
Die Grove Serial Camera ist eines der komplexeren Devices, welches von unserer Library unterstützt wird. Zur Kommunikation über den Serial Bus wird ein spezielles Protokoll eingesetzt. In den folgenden Unterkapiteln finden Sie weitere Informationen zu jenem Protokoll und unserer Implementation davon.

==== Protokoll
Die Datenübermittlung zwischen Kamera und Pi erfolgt über den Serial Bus und das OV528 Protokoll. Die einzelnen Kommandos umfassen jeweils 6 Bytes, welche zusammen als Paket übermittelt werden. Das nachfolgende Beispiel zeigt das SYNC Kommando, welches jeweils zu Beginn der Kommunikation vom Pi ausgesendet wird. Folgende Bytes werden übermittelt: AA0D00000000h.

.SYNC Kommando
image::Grove_Serial_Camera_SYNC_Command.png[500, 500, Grove Serial Camera SYNC]

==== Verbindung mit der Kamera aufbauen
Bevor Befehle an die Kamera gesendet werden können, muss eine Verbindung zwischen Kamera und Raspberry Pi etabliert werden. Dazu wird vom Host mehrmals ein SYNC Kommando auf den Serial Port geschrieben und auf eine Antwort von der Kamera gewartet. Durchschnittlich antwortet die Kamera nach 25 SYNC Kommandos mit einem ACK (AA0E0Dxx0000h). Auf die Empfangsbestätigung folgt das Kommando, welches die Kamera bestätigt. In diesem Fall das SYNC Kommando (AA0D00000000h). Gibt die Kamera nach 60 SYNC Befehlen noch immer keine Antwort, kann davon ausgegangen werden, dass etwas mit der Verkabelung der Kamera nicht stimmt oder der Controller der Kamera defekt ist.

.Verbindungsaufbau
image::Grove_Serial_Camera_Initialisation.png[500, 500, Grove Serial Camera Connection]

In unserer Java Klasse haben wir den Verbindungsaufbau in einer eigenen Funktion realisiert, welche vom jeweiligen Konstruktor aufgerufen wird. In einer While-Schlaufe wird das SYNC Kommando solange an die Kamera gesendet, bis diese eine Antwort auf den Serial Bus geschrieben hat. Ist dies nach 60 Versuchen nicht der Fall, wird die Initialisierung mit einem Fehler abgebrochen. Hat die Kamera eine Antwort gesendet, wird diese auf Ihre Korrektheit überprüft. Die ersten sechs Bytes müssen dem ACK Kommando entsprechen (AA0E0Dxx0000h). Bei den nächsten sechs Bytes muss es sich um das SYNC Kommando handeln (AA0D00000000h). Sofern dies der Fall ist, war der Verbindungsaufbau erfolgreich. Die Kamera ist nun bereit für die Entgegennahme von weiteren Befehlen.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/SerialCameraComponent.java[tags=SerialCamInit]
----

==== JPEG Foto anfordern
Nach dem erfolgreichen Verbindungsaufbau ist die Kamera bereit für das Schiessen von Bildern. Unsere Implementation stellt Bilder im JPEG Format in der Auflösung 640 x 480 zur Verfügung. Hierbei handelt es sich um die maximale Auflösung der Kamera. Theoretisch können auch Bilder in anderen Grössen und Formaten von der Kamera angefordert werden. Diese Formate werden von uns jedoch nicht unterstützt.

Um ein Bild von der Kamera zu erhalten, sind mehrere einzelne Schritte, Befehle und Bestätigungen nötig. Diese sind im folgenden Diagramm ersichtlich.

.Ablauf der Bildanforderung
image::Grove_Serial_Camera_Get_Picture.png[500, 500, Grove Serial Camera Get Picture]

==== Bildgrösser ermitteln
Zur Ermittlung der Bildgrösse wird die gewünschte Paketgrösse der einzelnen Pakete benötigt. Die Paketgrösse kann vom Anwender im Bereich von 16 bis 2048 Bits definiert werden. Die Default Paketgrösse ist 512 Bits.

Als erster Schritt wird die zuvor definierte gewünschte Paketgrösse an die Kamera gesendet und es wird auf eine Empfangsbestätigung der Kamera gewartet.

Anschliessend wird das Snapshot Kommando an die Kamera gesendet. Dieses Kommando bereitet die Kamera auf das Erzeugen eines Bildes vor. Auch hier wird wieder auf eine Empfangsbestätigung der Kamera gewartet.

Zu guter Letzt wird der Befehl zur JPEG Generierung an die Kamera übermittelt. Die Kamera antwortet auf dieses Kommando mit einer Empfangsbestätigung gefolgt von der Anzahl Bytes des Bildes, welches geschossen wurde.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/SerialCameraComponent.java[tags=SerialCamGetPictureLength]
----

==== Bild Pakete empfangen
Nachdem die Bildgrösse von der Kamera ermittelt wurde, kann der Host Paket für Paket von der Kamera über den Serial Bus anfordern. Wir fordern solange Pakete von der Kamera an, bis wir das letzte Paket von der Kamera erhalten haben. Das letzte Paket erkennen wir anhand der letzten zwei Bytes. Handelt es sich bei diesen um 0xFF gefolgt von 0xD9, wurde das komplette JPEG übermittelt. Bei den zwei Bytes handelt es sich nämlich um den Footer eines jeden JPEGs.

Da es bei der Übermittlung von Paketen immer zu Fehlern kommen kann, stellt das OV528 Protokoll einen Kontrollmechanismus zur Verfügung, über welchen Fehler identifiziert werden können. Bei den zwei letzten Bytes eines jeden Pakets handelt es sich um eine Prüfsumme, mit welchen die übermittelten Bilddaten überprüft werden können. Die Prüfsumme muss exakt der Summe der einzelnen übermittelten Bytes entsprechen. Ist dies der Fall, fordern wir das nächste Paket von der Kamera an. Stimmt die Prüfsumme jedoch nicht mit der Summe aller Bild-Bytes überein, fordern wir das fehlerhafte Paket erneut von der Kamera an. Damit kann sichergestellt werden, dass das erhaltene Bild immer fehlerfrei ist.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/SerialCameraComponent.java[tags=SerialCamGetPicture]
----

<<<

:sectnums!:
== TODO: Schluss

<<<
== TODO: Literaturverzeichnis
