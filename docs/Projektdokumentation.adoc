:toc: macro
:toc-title:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:imagesdir: ./assets/images
:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/FHNW-IP5-IP6/GPIOSimulator

image::FHNW.png[FHNW,382,59]
[discrete]
= IP5: GPIOSimoulator

*Semesterarbeit von*:

* Herr Jonathan Bättig (jonathan.baettig@students.fhnw.ch) 
* Herr Anessollah Ima (anessollah.ima@students.fhnw.ch)

*FHNW* +
*Hochschule für Technik* +
*Studiengang* : Informatik +
*Semester* : 6BB

*Betreuende Dozenten*:

* Frau Dr. Barbara Scheuner (barbara.scheuner@fhnw.ch) 
* Herr Dr. Dieter Holz (dieter.holz@fhnw.ch) 

*Datum*: {docdate}


<<<
[discrete]
== Summary 
TBD am Ende: + 
Anhand dieses Textes soll eine Person entscheiden können, ob sie sich für ihr Thema interessiert.

. Was wurde erreicht?
. Was sind die Ergebnisse
. Warum wurde es gemacht? Was war das Problem? 
. Wie wurde es gemacht/untersucht/getestet?

<<<
[discrete]
== Vorwort

<<<
[discrete]
== Inhaltsverzeichnis
toc::[]

<<<
:sectnums!:
== Einleitung
:sectnums:

<<<
== Theoretischer Teil

=== Anforderungen
Die nachfolgende Tabelle enthält alle Anforderungen an den GPIO Simulator, welche wir während der Requirements Analyse identifizieren konnten. Die einzelnen Anforderungen haben wir drei Prioriäten zugeteilt.

* *Priorität 1*: Anforderungen an den MVP
* *Priorität 2*: Unterstützung der Grove Sensoren
* *Priorität 3*: Implementation User Interface

Die Umsetzung der Requirements soll gemäss Ihrer Priorität erfolgen.

.Anforderungen
[cols="1,7,1"]
|===
|Nummer |Beschreibung  |Priorität

|{counter:reqNumber} 
|Anwender sollen unabhängig von der Hardwareverfügbarkeit an ihren Raspberry Pi Projekten arbeiten können.
|1

|{counter:reqNumber}
|Anwender sollen auf eine einfache und intuitive Art konfigurieren können, ob der Code auf dem GPIO Simulator oder auf dem Raspberry Pi ausgeführt werden soll.
|1

|{counter:reqNumber}
|Anwender sollen das Logging Level des GPIO Simulators konfigurieren können, ohne dass das Projekt neu gebaut werden muss.
|1

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des Raspberry Pi via Pi4J setzen können.
|1

|{counter:reqNumber} 
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des GPIO Simulators setzen können.
|1

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des Raspberry Pi via Pi4J auslesen können.
|1

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des GPIO Simulators auslesen können.
|1

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des Raspberry Pi via Pi4J setzen können.
|2

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des GPIO Simulators setzen können.
|2

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des Raspberry Pi via Pi4J auslesen können.
|2

|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des GPIO Simulators auslesen können.
|2

|{counter:reqNumber}
|Den Benutzern des GPIO Simulators sollen Code Beispiele für die gängigen Sensoren und Aktuatoren zur Verfügung stehen.
|2

|{counter:reqNumber}
|Anwender sollen vom GPIO Simulator Feedback in einem User Interface erhalten.
|3

|{counter:reqNumber} 
|Anwender sollen im User Interface des GPIO Simulators alle gängigen Sensoren und Aktuatoren zur Verfügung haben.
|3

|{counter:reqNumber}
|Anwender sollen im User Interface des GPIO Simulators Sensoren und Aktuatoren mit dem Grove Hat verbinden können.
|3

|{counter:reqNumber} 
|Anwender sollen die Konfiguration der Sensoren und Aktuatoren des GPIO Simulators speichern und wiederverwenden können.
|3
|===

<<<
=== Projektplan

<<<

=== Hardware

.Micro Computer
[cols="1,7"]
|===
|Anzahl |Typ
|2 |https://www.raspberrypi.org/products/raspberry-pi-3-model-b-plus/[Raspberry Pi 3 B+^]
|===

.Freenove Box
[cols="1,7"]
|===
|Anzahl |Typ
|1 |http://www.freenove.com/index.html[Freenove Ultimate Starter Kit for Raspberry Pi] (FNK0020)
|===

.Sensoren & Aktuatoren
[cols="1,7"]
|===
|Anzahl |Typ
|1 |https://wiki.seeedstudio.com/Grove_Base_Hat_for_Raspberry_Pi/[Grove Base Hat for Raspberry Pi^]
|1 |https://wiki.seeedstudio.com/Grove_Base_Hat_for_Raspberry_Pi/[Grove Base Hat for Raspberry Pi^]
|3 |https://wiki.seeedstudio.com/Grove-TemperatureAndHumidity_Sensor/[Grove - Temperature & Humidity Sensor^]
|3 |https://wiki.seeedstudio.com/Grove-Touch_Sensor/[Grove – Touch^]
|3 |https://wiki.seeedstudio.com/Grove-Buzzer/[Grove – Buzzer^]
|2 |https://wiki.seeedstudio.com/Grove-Magnetic_Switch/[Grove - Magnetic Switch^]
|2 |https://wiki.seeedstudio.com/Grove-Rotary_Angle_Sensor/[Grove Rotary Angle Sensor^]
|2 |https://wiki.seeedstudio.com/Grove-Gesture_v1.0/[Grove - Gesture^]
|1 |https://wiki.seeedstudio.com/Grove-Button/[Grove - Button^]
|1 |https://wiki.seeedstudio.com/Grove-Light_Sensor/[Grove – Light Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Serial_Camera_Kit/[Grove - Serial Camera^]
|1 |https://wiki.seeedstudio.com/Grove-Light-Gesture-Color-Proximity_Sensor-TMG39931/[Grove – Light & Gesture & Color & Proximity Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-I2C_Color_Sensor/[Grove - I2C Color Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Temperature_Sensor_V1.2/[Grove – Temperature Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Sound_Sensor/[Grove – Sound Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Ultrasonic_Ranger/[Grove – Ultrasonic Ranger^]
|1 |https://wiki.seeedstudio.com/Grove-LED_Strip_Driver/[Grove – LED Strip Driver^]
|1 |https://wiki.seeedstudio.com/Grove-125KHz_RFID_Reader/[Grove - RFID Reader^]
|1 |https://www.dexterindustries.com/pivotpi/[PivotPi Board^]
|1 |https://www.raspberrypi.org/products/camera-module-v2/[Raspberry Pi Camera V2^]
|===

=== Software
==== Pi4J
Das Projekt Pi4J bietet vollzugriff auf die I/O Funktionalität des Raspberry Pi über eine objektorientierte Java API. Die Bibliothek abstrahiert die komplexe Hardware Programmierung und ermöglicht es Java Programmieren, sich auf die Implementation ihrer Logik zu konzentrieren.

* Exportieren und Importieren von GPIO Pins
* Konfigurieren der GPIO Pin Flussrichtung
* Lesen und Schreiben des GPIO Pin State
* Pulse Width Modulation (Hardware & Software)
* Erstellen von GPIO State Listeners (Hardware Interrupt)
* Automatisches setzen eines Pin State bei Programmende (GPIO Shutdown)
* Senden und empfangen von Daten via serielle Schnittstelle (RS232)
* Support für Kommunikation über den I2C Bus (Inter-Integrated Circuit)
* Support für Kommunikation über den SPI Bus (Serial Peripheral Interface)
* Erweiterbarer GPIO Provider mit Support für GPIO Extension Boards
* Zugriff auf System- und Netzwerkinformationen des Raspberry Pi
* Wrapper Klassen für den direkten Zugriff auf WiringPi

Zu Projektstart war geplant, dass wir für unser Projekt die Pi4J Bibliothek in der aktuellsten Snapshot Version 1.4 verwenden werden, welche sich noch in Entwicklung befindet. Basis für diesen Entscheid war die Tatsache, dass Pi4J 1.4 Java 11 unterstützen soll. Die release Version 1.2 unterstützt lediglich Java 8 und ist deshalb weniger interessant. Im Verlauf unseres Projekts mussten wir diesen Entscheid jedoch überdenken. Es hat sich herausgestellt, dass der aktuelle Stand von Pi4J 1.4 nicht die gewünschte Stabilität für unser Projekt bieten kann. Bei der Arbeit an unseren Code Beispielen für den I2C LCD-Display sind wir auf Probleme gestossen, welche direkt mit der Pi4J Version zusammenhängen. Die I2C Schnittstelle wird in Kombination mit Java 11 nicht unterstützt. Zu diesem Problem gibt es bereits ein offenes GibHub Issue auf dem Pi4J Projekt, welches als Workaround ein Downgrade auf Java 8 vorschlägt. Grundsätzlich war es aber das Ziel, durch den Einsatz von Pi4J 1.4 Java 8 zu vermeiden. Zusätzlich sind die Device Klassen, welche ein einfaches Interfache für die Ansteuerung einer Vielzahl von Sensoren und Aktuatoren erlaubt, in Pi4J 1.4 nicht mehr enthalten. Diese wurden von den Entwicklern aus dem Projekt entfernt, da die Device Implementation kaum von Anwendern benutzt wurden. Für den GPIO Simulator sind diese Device Implementationen allerdings sehr interessant. Sie vereinfachen die Ansteuerung der Hardwarekomponenten und sind somit bestens für Studenten in den ersten Semestern geeignet.

Die Tatsache, dass in Pi4J 1.4 die Device Klassen fehlen und Java 11 wohl doch noch komplett unterstütz wird, hat uns dazu bewegt, dass wir für unser Projekt auf die aktuelle Release Version 1.2 zurückgreifen.

==== Java
Aus kompatibilitätsgründen mit Pi4J 1.2 verwenden wir Java 8.

==== Gradle

==== Log4j

=== Analyse Applikationsdesign
Durch die Ergebnisse der Anforderungsanalyse haben wir viele neue Erkentnisse gewonnen. Diese Erkenntnisse bilden die Basis für technische Entscheidungen, welche wir in diesem Kapitel festhalten.

==== Logging
Die Log Funktionalität ist für unser Produkt essenziell. Die Umsetzung des Loggins ist Bestandteil des Minimum Viable Product. Ziel ist es, dass alle Interaktionen mit den GPIO Pins und Grove Adaptoren in einem geeigneten Format geloggt werden. Für Java stehen bereits diverse Logging Frameworks zur verfügung. Ein weit verbreiteter und beliebter Vertreter ist Log4j 2 von Apache. Es beitet die Funktionalität, Logs in eine Rolling File zu schreiben. Diese Funktionalität eignet sich hervorragen für unsere Zwecke, weshalb wir uns für die Verwendung dieses Frameworks entschieden haben.

==== Benutzeroberfläche
Ein wichtiger Entscheid, welcher in diesem Projekt getroffen werden muss, ist die Integrationsart der Benutzeroberfläche des Simulators. Unsere Analyse hat gezeigt, dass es zwei verschidene möglichkeiten gibt, wie das User Interface des Simulators integriert werden kann. Einerseits können wir den Simulator als Standalone Applikation zur Verfügung stellen, andererseits könnte der Simulator auch direkt als Dependance in das Projekt der Anwender inkludiert werden. Beide Vorgehensweisen sind im Kern gleich, haben aber ihre jeweiligen Vor- und Nachteile.

===== Integration als Dependency
Bei diesem Integrationstyp wird der komplette Simulator zu einem festen Bestandteil des Raspberry Pi Projektes des Anwenders. Das Projekt umfasst nebst dem vom Anwender selbst geschriebenen Code, welcher schlussendlich auf dem Raspberry Pi ausgeführt werden soll, zusätzlich das gesamte User Interface des Simulators. Dies führt dazu, dass das Projekt des Anwenders um einiges grösser wird. Allerdings würde uns die direkte Integration unsere Arbeit erleichtern. Die Kommunikation zwischen User Code und UI könnte über die uns bereits aus dem Unterricht bekannten UI Bindings von JavaFX implementiert werden. Des Weiteren gibt uns die Integration des Simulators in das Projekt des Anwenders mehr Freiheit bezüglich der Konfiguration des Simulators. Einerseits könnte das User Interface gleich aus dem Code des Anwwenders generiert werden, andererseits kann die Konfiguration der GPIO Schnittstellen auch im Simulator selbst erfolgen.

[.underline]#*Konfiguration via Code*#

Unter Verwendung dieser Konfigurationsart entscheidet der Code des Benutzers, welche Sensoren und Aktuatoren an welche virtuellen Anschlüsse des Simulators angeschlossen werden. Sobald der Benutzer den Code unter Verwendung des GPIO Simulators startet, generiert der Simulator das UI gemäss den im Code verwendeten Pins, Sensoren und Aktuatoren. Ein wesentlicher Vorteil dieses Konfigurationstyps ist sicher die Einfachheit der Anwendung. Der Benutzer muss sich lediglich um seinen Code kümmern. Genau so wie die Sensoren im Code verwendet werden, werden diese auch im Simulator angezeigt. Es ist somit ausgeschlossen, dass Pins verwendet werden, welche nicht mit Sensoren oder Aktuatoren verbunden sind. Dies kann aber auch ein Nachteil sein, da diese Konfigurationsart nicht wirklich der Realität entspricht, welche man in einem IoT Projekt antrifft. Dort ist der Anwender für die Verkabelung der Sensoren und Aktuatoren mit dem Raspberry Pi verantwortlich, nicht der von im verfasste Code. Es kann durchaus passieren, dass beispielsweise die falschen Pins verbunden werden. Dieser Aspekt würde unter Verwendung der aus dem Code generierten Konfiguration verloren gehen.

.Dependency Integration mit Konfiguration im Code 
image::Dependency_Integration_Code.png[Design Dependecy]

[.underline]#*Konfiguraiton via Simulator*#

Bei diesem Konfigurationstyp wird die Konfiguration direkt im Simulator vorgenommen. Nachdem ein Anwender seinen Code Ausführt, öffnet sich das UI des GPIO Simulators. Der Benutzer kann nun via Drag and Drop Sensoren und Aktuatoren im dafür vorgesehenen Bereich platzieren und diese mit den GPIO oder Grove Pins des virtuellen GroveHat verbinden. Nachdem der Benutzer die Konfiguration abgeschlossen hat, kann er dies über einen Button bestätigen und die Simulation startet. Der Vorteil dieses Konfigurationstyps liegt ganz klar in der Realitätsnähe, welche über die Konfiguration via Code fehlt. Der Benutzer hat die Möglichkeit, Sensoren und Aktuatoren falsch anzuschliessen und muss dem Problem selbst nachgehen. Dies erhöht den Lerneffekt und trägt zum Verständnis bei. Nachteil ist allerdings, dass die Konfiguration erst nach dem Starten des Codes gemacht werden kann.

.Dependency Integration mit Konfiguration im Simulator
image::Dependency_Integration_Simulator.png[Design Dependecy]

===== Integration als Standalone Applikation
Bei diesem Integrationstyp wird der Simulator zu einer separaten Applikation, die auf einem eigenen Prozess läuft. Der Code des Anwenders läuft komplett unabhängig vom Simulator selbst. Die Unabhängigkeit der Projekte macht die Kommunikation der beiden Programme komplizierter, da ein neuer indirekter Weg für die Datenübertragung gefunden werden muss. Eine Standalone Applikation hat aber den Vorteil, dass die Konfiguration des Simulators nicht erst zur Laufzeit stattfinden müsste. Man könnte den Simulator also starten und konfigurieren, ohne den Code bereits geschriben zu haben. Er kann dann die Simulation starten und gegen den Simulator programmieren. Immer wenn der Anwender seinen Code ausführt, kann er direkt im Simulator sehen, ob der Code die gewünschte Wirkung hat. Dieser Integrationstyp Simuliert die Realität sicher am besten, da der Raspberry Pi auch eine separate Instanz ist.

.Standalone Integration 
image::Standalone_Integration.png[Design Standalone]

===== Entscheidung
TODO: Entscheidung dokumentieren, sobald gefallen.

<<<


=== Simulatiosstrategie
Zu Beginn war es unser Plan das Factory Design Pattern zu verwenden, um zwischen dem Simulator und dem richtigen Hardwarezugriff mit Pi4J zu differenzieren. Da der erste Zugriffspunkt in Pi4J immer eine Factory war, wie z. B die GpioFactory, I2CFactory oder die SerialFactory. 

Der Simulator und Pi4J wären dann in einem Projekt gekapselt und man müsste nur im obersten Zugriffspunkt eine kleine Veränderung vornehmen, um zwischen Simulator und Pi4J zu wechseln.

.Simulator Factory
image::GpioSimulatorFactory_Idee.png[Design Dependecy]

Dies hat sich leider nicht bewährt, da Pi4J eine Dependency ist die wir nicht verändern können. 

Wir bräuchten Interfaces oder Abstraktionen von den Factories in Pi4J, um sie in einer höheren Factory zu kapseln und im Simulator zu implementieren. Solche Interfaces gibt es in Pi4J nicht. Es gäbe noch die Möglichkeit eine eigene FHNW-Version von Pi4J zu schreiben die solche Schnittstellen hat, aber das wäre schwierig im Nachhinein zu implementieren und in Zukunft zu warten. Das war das eindeutige Zeichen, dass wir unseren Plan anpassen müssen.

Zunächst gilt es, das gesamte Pi4J-Paket zu analysieren und sich damit neue Simulationsstrategien zu überlegen.

Pi4J ist aufgeteilt in:

. *pi4j-core*: +
Stellt alle Klassen und Methoden zur Verfügung, um direkt auf die GPIO Pins zu zugreifen. 
. *pi4j-device*: +
Ist ein Abstraktions Layer, der die Nutzung vereinfacht, indem es eigene Klassen für alle Sensoren und Aktoren zur Verfügung stellt.
. *pi4j-distribution*: +
Enthält Scripts und Dateien, welche man für die Installation und Deinstallation benötigt.
. *pi4j-example*: + 
Enthält Beispiele für Verschiedene Devices, die mit Pi4J angesteuert werden können.
. *pi4j-gpio-extension*: +
Enthält Software für die erleichterte Verwendung von Extenstion Boards wie z.B PiFace
. *pi4j-native*: +
Enthält native Scripts für weitere Entwicklungsboards wie NanoPi oder BananaPi

Für die Verwendung und schlussendlich die Simulation benötigen wir ausschliesslich die ersten beiden Teile: pi4j-core und pi4j-device.

==== Simulator = Tutorial
Der Hauptzweck dieses Projektes besteht darin, die Studentinnen und Studenten der ersten Semester bei den IoT Projekten zu unterstützen. Da der Umfang der Simulation von Pi4j zu gross wäre, besteht auch die Möglichkeit auf den Simulationsaspekt des Projektes komplett zu verzichten. +

In diesem Fall müsste man alle Beispiele für die Verwendung der wichtigsten Sensoren und Aktoren so ausarbeiten, dass es den Studierenden als direkte Referenz dienen kann. Damit könnte man auch die hardwarenahe Arbeit reduzieren, sodass die Studierenden wieder vermehrt parallel arbeiten könnten.

==== Simulator auf Ebene von Pi4J-Core
Da Pi4J-Core der Kern von Pi4J ist und direkt mit den GPIO Pins arbeitet, müsste der Simulator auch auf dieser Ebene funktionieren, wenn die Simulation für jeglichen Source Code vom Endbenutzer funktionieren soll.

Die Schwierigkeit einer Simulation auf dieser Ebene besteht hauptsächlich im Umfang von der Pi4J-Core Library und darin, dass es schwer vorhersehbar ist, welche Bereiche wirklich gebraucht werden. Das hat man bei der Arbeit an den Beispielen für die Sensoren und Aktoren gemerkt.
Für manche Geräte benötigten wir Bereiche von Pi4J-Core die äusserst umfangreich waren, wie z.B WiringPi. Es ist sehr schwierig abzuschätzen wie weit die Simulation in solchen Fällen gehen müsste.

Auf dieser Ebene zu simulieren, würde dazu führen, dass der Simulator  sehr umfangreich wäre und ein höheres Risiko dafür bestünde, dass die Arbeit im Backend zu gross wird. Ausserdem könnten die Usability und die Arbeit an der Benutzeroberfläche dadurch zu kurz kommen.

Wenn man mit viel Arbeit konfrontiert wird, dann muss man sich immer die Frage stellen, ob diese Arbeit auch zielführend ist für das Gesamtprojekt.

<TBD> Evtl. Bild von Pi4J-Core hinzufügen Klassendiagramm/ Dependency  </TBD>

==== Simulator auf Ebene von Pi4J-Device
Der Pi4J-Device Layer ist von der Grösse her definitiv überschaubarer, als Pi4J-Core, da es als Abstraktions Layer direkt Klassen anbietet für die einzelnen Devices.

Ein Simulator auf dieser Ebene würde die Klassen von Sensoren und Aktoren für den Simulator neuimplementieren. Das hätte den Vorteil, dass die Arbeit im Backend einen Rahmen hätte, der ein weniger grosses Risiko birgt als bei Pi4J-Core.

Leider wird Pi4J-Device in zukünftigen Releases nicht mehr weitergeführt. Aus diesem Grund bräuchte man eine eigene Pi4J-Device Version von der FHNW, welche wir weiterführen und erweitern können, wenn  neue Devices benötigt werden. Da Pi4J-Device auch kleiner ist als Core wird es einfacher sein, es zu warten.
Der Simulator würde dann in der tiefsten Ebene mit Simulationsklassen der FHNW-Version der Pi4J-Device Library arbeiten.


==== Entscheidung
Wir haben uns für die Simulation auf Ebene von Pi4J-Device entschieden, da das Risiko und der Umfang der Arbeit an Pi4J-Core zu gross und zu unvorhersehbar wäre. 
Der Tutorialaspekt des Projekt geht dabei auch nicht verloren, da wir für alle Geräte 3 Beispiele machen werden:

. Ein Beispiel, welches direkt mit den Pins arbeitet mittels Pi4J-Core

. Ein Beispiel, welches die Pi4J-Device Klasse des Geräts verwendet

. Ein Beispiel, welches den GPIO-Simulator verwendet

Mit den verschiedenen Beispielen sind die angehenden Studentinnen und Studenten dann sehr flexibel für ihre Projekte und können auch hoffentlich etwas von den verschiedenen Implementierungen lernen.

== Praktischer Teil

=== Software Architektur

=== Code Beispiele
==== GPIO
===== Blink LED

===== Button Click

===== LCD System Time

===== LCD System Time I2C

===== Motor Direction

===== Motor Speed Hardware PWM

===== Motor Speed Software PWM

===== Serial Camera

===== Servo Motor

===== Stepper Motor

<<<

:sectnums!:
== Schluss

<<<
== Literaturverzeichnis

<<<
== Ehrlichkeitserklärung

<<<
== Anhang
