:toc: left
:toc-title:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:sourcedir: ../src/main/java
:imagesdir: ./assets/images
:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/FHNW-IP5-IP6/GPIOSimulator

image::FHNW.png[FHNW,382,59]
[discrete]
= IP5: FHNW Pi4J Tutorial

*Autoren*:

* Herr Jonathan Bättig (jonathan.baettig@students.fhnw.ch) 
* Herr Anessollah Ima (anessollah.ima@students.fhnw.ch)

*FHNW* +
*Hochschule für Technik* +
*Studiengang* : Informatik +
*Semester* : 6BB

*Betreuende Dozenten*:

* Frau Dr. Barbara Scheuner (barbara.scheuner@fhnw.ch) 
* Herr Dr. Dieter Holz (dieter.holz@fhnw.ch) 

*Datum*: {docdate}

<<<
[discrete]
== Inhaltsverzeichnis
toc::[]

<<<
:sectnums!:
== TODO Einleitung
:sectnums:

<<<

== Hardware 

=== Raspberry Pi

=== Grove Sensoren & Aktuatoren

=== Grove Base Hat
Grove Sensoren und Aktuatoren sind beliebt und werden oft in Projekten eingesetzt. Sie verfügen über simple Steckverbindungen, sogenannte Adapter, welche in Kombination mit dem Grove Base Hat eine sichere und fehlerfreie Verbindung mit dem Raspberry Pi garantieren.

.Grove Base Hat
image::Grove_Base_Hat.png[500, 500, Grove Base Hat]

Der Grove Base Hat stellt Adapter für PWM, Digital, Analog, UART sowie I2C zur Verfügung. Zusätzlich werden alle GPIO Pins auf den Hat projiziert. Unsere Implementation des Grove Adapters unterstützt alle diese Anschlüsse.

[source,java]
----
include::{sourcedir}\fhnwgpio\grove\GroveAdapter.java[tags=GroveAdapter]
----

Die Sensoren und Aktuatoren können über unsere Implementation sehr einfach verwendet werden. Das untere Beispiel zeigt, wie ein Potentiometer, welcher am Grove Base Hat Adapter A0 angeschlossen ist, erzeugt und abgefragt werden kann.

[source,java]
----
PotentiometerComponent potentiometer = new PotentiometerComponent(GroveAdapter.A0);
potentiometer.getValue()
----

==== PWM
Der Grove Base Hat unterstütz die Hardware PWM Pins 12 sowie 13. Beide Pins sind im selben Adapter vereinigt.

==== UART
Der UART Adapter macht den Serial Bus der Raspberry Pi für Grove Sensoren und Aktuatoren verfügbar. Er benutzt die GPIO Pins 14 und 15. An diesem Port würden wir die Grove Serial Camera anschliessen, wenn diese mit 3.3 Volt kompatibel wäre.

==== Digital
Der Grove Base Hat stellt sechs digitale Adapter zur Verfügung. Die Adapter stellen die Standard GPIO Pins des Pi dar. Die Pin Nummern entsprechen den Zahlen auf dem Board. Beispielsweise entspricht der Adapter D22 den Pins 22 und 23.

==== Analog
Der Raspberry Pi selbst besitzt nur digitale GPIO Pins. Hier stellt uns der Grove Base Hat also zusätzliche Funktionalität zur Verfügung. An die vier analogen Adapter können analoge Sensoren und Aktuatoren angeschlossen werden. Diese kommunizieren mit einem Chip, welcher sich auf der Rückseite des Hats befindet. Dieser Chip wandelt dann die analogen Daten in ein digitales Format um. Zusätzlich implementiert der Chip das I2C Interface, über welches er mit dem Pi kommunizieren kann.

Der Chip hat die I2C Adresse 0x04. Die einzelnen analogen Anschlüsse haben jeweils eine eigene Device Adresse.

* **A0**: 0x30
* **A2**: 0x32
* **A4**: 0x34
* **A6**: 0x36

==== I2C
Die drei I2C Anschlüsse sind alle mit dem I2C Bus 1 des Raspberry Pi verbunden. Mit I2C können mehrere Devices auf einmal angesteuert werden.

=== Breadboard


=== Software

==== Pi4J

==== Java

== Setup des RaspberryPi
Bevor Sie mit der Implementation ihres ersten Raspberry Pi Projekts starten können, muss der Mini-Computer aufgesetzt werden. Im Gegensatz zu den verschiedenen im Handel erhältichen Micro Controllern, wie Beispielsweise der Arduino Uno, benötigt der Pi ein Betriebssystem. Wir verwenden das auf Linux basierende System Raspbian, eine speziell für den Raspberry Pi modifiziertes Derbian.

=== Vorbereitung der Mini SD-Karte
Wie bereits erwähnt, verwenden wir für den Betrieb des Raspberry Pi das Linux OS Raspbian. Das Betriebssystem werden Sie später auf die Ihnen zur Verfügung gestellte Mini SD-Karte installieren.

In einem ersten Schritt laden Sie bitte das Raspbian Image aus dem Internet auf Ihren Rechner und speichern die Datei ab. Besuchen Sie hierfür die Download-Website der Raspberry Organisation: + 
https://www.raspberrypi.org/downloads/raspbian/

._Raspbian Download_
image::./installation/raspbianDownload.png[width=75% raspbian Download]

Wählen Sie nun die Raspbian Version `Raspbian Buster with desktop` aus. Sobald Ihr Browser den Download abgeschlossen hat, extrahieren Sie bitte den Zip-Ordner an eine beliebige Stelle. Im extrahierten Ordner befindet sich eine .img-Datei, welche wir in den folgenden Installationsschritten benötigen werden. Merken Sie sich also, wo auf dem Dateisystem der entpackte Folder liegt.

Damit Sie das Raspbian Image auf Ihre SD-Karte installieren können, brauchen Sie eine geeignete Disk Imaging Software. Wir empfehlen Ihnen dafür balenaEtcher zu verwenden. Es gibt aber auch andere dafür geeignete Programme.

Wenn Sie sich ebenfalls für balenaEtcher entscheiden, können Sie das Programm über den folgenden Link direkt von der balena Webseite herunterladen und installieren: + 
https://www.balena.io/etcher/

._balenaEtcher Download_
image::./installation/balenaDownload.png[width=75% balenaEtcher Download]

Nachdem Sie balenaEtcher installiert haben, können Sie die Applikation starten. In nur drei einfachen Schritten spiegelt balenaEtcher das Raspbian Image auf Ihre Mini SD-Karte.

._balenaEtcher Startbildschirm_
image::./installation/balenaStart.png[width=75% balenaEtcher Startbildschirm]

. Wählen Sie in einem ersten Schritt die .img-Datei des zuvor heruntergeladenen Raspbian aus.
. Wählen Sie nun die Mini SD-Karte aus, welche Sie an Ihren PC angeschlossen haben. Bitte beachten Sie, dass die SD-Karte während der Installation formatiert wird und somit alle sich auf der Karte befindenden Daten unwiederruflich gelöscht werden.
. Klicken Sie auf "Flash!" um die Installation des Images zu starten. Dieser Prozess kann einige Minuten in Anspruch nehmen.

Sobald der Flash Vorgang abgeschlossen wurde, ist Raspbian auf der SD-Karte installiert und das OS ist betriebsbereit.

=== Raspberry Pi mit zusätzlicher Hardware nutzen
Wenn Sie den Raspberry Pi als normalen Desktop Rechner verwenden möchten, können Sie die vorbereitete Mini SD-Karte in den Pi einsetzen und weitere Hardware wie Maus, Monitor und Tastatur direkt an Ihren Pi anschliessen. Sobald Sie den Computer an das Stromnetz anschliessen, fährt Raspbian hoch und eine Login Maske erscheint.

Für das initiale Login auf dem Pi können Sie die folgenden Standard Credentials verwenden:

* *User*: pi
* *Passwort*: raspberry

=== Raspberry Pi ohne zusätzliche Hardware nutzen
Es gibt verschiedene Gründe, weshalb Sie den Raspberry Pi ohne zusätzliche Hardware verwenden möchten. Womöglich erfüllt der Pi die Mindestanforderungen Ihrer bevorzugten Entwicklungsumgebung nicht oder Ihnen steht schlicht und einfach nicht die nötige Hardware zur Verfügung. In diesem Kapitel möchten wir Ihnen aufzeigen, wie Sie den Mini Computer ganz ohne zusätzliche Hardware konfigurieren und verwenden können. Sie benötigen dazu ledeglich ein USB-Kabel und Ihren Laptop.

Um mit dem Raspberry Pi ohne zusätzliche Hardware arbeiten zu können, wird SSH verwendet. Damit Sie via SSH auf den Pi zugreifen können, benötigen Sie eine SSH Software. Ein beliebtes Tool ist PuTTY. Sie können es unter folgendem Link direkt vom Hersteller herunterladen und auf Ihrem Rechner installieren: +
https://www.putty.org/

==== Zugriff über SSH
Bevor Sie sich mit PuTTY via SSH auf den Pi einloggen können, müssen Sie SSH in Raspbian aktivieren. Dazu legen Sie die SD-Karte erneut in Ihren PC ein und navigieren anschliessend mittels Datei-Explorer in den `boot` Folder der SD-Karte.

Jetzt müssen Sie verschiedene Einstellungen direkt an den markierten Files im `boot` Ordner vornehmen:

._boot Ordner_
image::./installation/bootFolder.png[width=75% boot Ordner]

* Im File `config.txt` müssen Sie ganz am Schluss den folgenden Snippet hinzufügen: +
[source]
----
dtoverlay=dwc2
----

* Im File `cmdline.txt` müssen Sie nach dem Text "rootwait" suchen und danach den folgenden Snippet hinzufügen: +
[source]
----
modules-load=dwc2,g_ether
----

Der relevante Ausschnitt des Files sieht dann zum Beispiel so aus: 

._cmdLine File_
image::./installation/cmdLine.png[width=75% cmdLine file]

Zu guter Letzt erstellen Sie ein leeres File ohne Dateiendung mit dem Namen `ssh`. Um dies zu erreichen, können Sie beispielsweise ein neues Textfile erstellen und dieses `ssh` nennen. Nun entfernen Sie die Dateiendung .txt.

._SSH aktivieren_
image::./installation/activateSSH.png[width=75% activate SSH]

Nun können Sie die Mini SD-Karte wieder in den Raspberry Pi einlegen und diesen mittels USB-Kabel an Ihren Computer anschliessen. Beim Startup von Raspbian untersucht das System den boot Folder und lädt Ihre neuen Einstellungen. Anschliessend können Sie PuTTY starten und mit der folgenden Konfiguration auf den Pi zugreifen.

._SSH Zugriff mit PuTTY_
image::./installation/SSHputty.png[width=65% SSH Zugriff]

Im neuen Shell Fenster können Sie sich mit den Standard Credentials anmelden und den Raspberry Pi über die Konsole verwenden.

* *User*: pi
* *Passwort*: raspberry

._Login in PuTTY_
image::./installation/puttyLogin.png[width=75% Login in PuTTY]


==== Zugriff über WiFi
Die Verbindung zum Raspberry Pi via SSH funktioniert auch kabellos. Dafür muss sich Ihr Computer lediglich im gleichen Netzwerk befinden wie der Raspberry Pi. Zum Beispiel bei Ihnen Zuhause im WLAN oder über Ihren mobilen HotSpot. Damit der Pi auf das WLAN zugreifen kann, müssen Sie die SD-Karte erneut an Ihren Laptop anschliessen und eine neue Datei im boot Ordner erstellen. Das `wpa_supplicant.conf` File.

Wenn Sie bereits mit dem Pi über Kabel verbunden sind, können Sie die Datei auch direkt über die PuTTY Konsole erstellen. Mit dem unteren Befehl wird das File mit dem Text Editor `nano` erstellt.

[source]
----
sudo nano /etc/wpa_supplicant/wpa_supplicant.conf
----

[source]
----
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1
country=CH

network={
    ssid="NETZWERK"
    psk="PASSWORT"
}
----

Bei `ssid` müssen Sie Ihren Netzwerknamen angeben und bei `psk` das Passwort. Sobald Sie die nötigen Einstellungen abgeschlossen haben, speichern Sie die getätigten Änderungen. Sofern nötig, schliessen Sie die SD-Karte wieder an den Raspberry Pi an.

Jetzt können Sie in PuTTY die IP-Adresse Ihres Raspberry Pi eingeben und sich somit direkt über das WLAN mit ihm verbinden.

Die IP Adresse Ihres Raspberry Pi können Sie über den Befehl `hostname -I` anzeigen lassen, sofern Sie bereits über Kabel mit dem Pi verbunden sind. Alternativ können Sie auch ein Tool auf Ihrem Laptop installieren, welches Ihr Netzwerk nach IPs scannt. Dafür haben wir den Advanced IP Scanner verwendet. Er ist einfach zu verwenden und seine Funktionalität ist selbsterklärend. Das Tool kann unter dem folgenden Link für Windows Rechner heruntergeladen werden: +
https://www.advanced-ip-scanner.com/de/

._Advanced IP Scanner_
image::./installation/advanced_ip_scanner.png[width=75% Advanced IP Scanner]

==== Zugriff auf UI via VNC Viewer
Um ohne Monitor von den Vorzügen des grafischen User Interface von Raspbian profitieren zu können, kann man die VNC Funktionalitäten des Raspberry Pi verwenden. Dieses Feature muss allerdings zuerst in den Einstellungen des Raspberry Pi aktiviert werden.

. Die Raspberry Pi Konfiguration mit dem Befehl `sudo raspi-config` öffnen.
. Unter `Interfacing Options` zu `VNC` navigieren und die Auswahl bestätigen.

Der Pi ist nun für die Verwendung von VNC konfiguriert. Jetzt müssen Sie noch ein entsprechendes Tool auf Ihrem Rechner installieren. Wir haben mit der Software Real VNC Viewer gute Erfahrungen gemacht und würden Ihnen ebenfalls empfehlen, dieses Tool zu verwenden. Es untersützt eine breite Palette von Betriebssystemen, auf welchen es installiert werden kann. Das Tool kann über diese Webseite bezogen werden: + 
https://www.realvnc.com/de/connect/download/viewer/

Beim Startup des Tools muss zuerst eine neue Verbindung angegeben werden. Diese wird dann für die künftige Verwendung abgespeichert.

._VNC Viewer Zugriff auf Pi_
image::./installation/VNCViewer.png[width=70% VNC Viewer Zugriff auf Pi]

Nach einem kurzen Verbindungsaufbau öffnet sich ein neues Fenster, welches einem den Remote Zugriff auf das User Interface des Raspberry Pi erlaubt.

._VNC Viewer GUI von Raspbian_
image::./installation/VNCViewerGUI.png[width=70% VNC Viewer GUI von Raspbian]

Es kann gut sein, dass die Auflösung sowie die Grösse der Icons zu Beginn noch nicht optimal ist. Die Einstellungen können Sie wie folgend anpassen:

* *Auflösung*: + 
    _Preferences -> Raspberry Pi Configuration -> Display_ +
    Hier können Sie unter "Set Resolution" die Auflösung verändern. Es kann sein, dass Sie zusätzlich die Option _"Underscan"_ deaktivieren müssen, weil sie eventuell Ihre Einstellungen zur Auflösung überschreibt.

* *Icon Grösse*: + 
    _Preferences -> Appearance Settings -> System -> Defaults_ + 
    Hier können Sie die Grösse der Icons gemäss Ihren Präferenzen ändern.

=== TODO: Installation von zusätzlicher Software auf dem Pi

==== Java

==== Git

==== Gradle

== Code auf dem Pi bauen
Es ist möglich den Code in intelliJ auf dem eigenen Rechner zu schreiben und diesen dann auf den Pi zu deployen. Das hat den wesentlichen Vorteil, dass man nicht mit der langsamen Entwicklungsumgebung des Raspberry Pi arbeiten muss und auch nicht jede kleinste Änderung in git pushen muss, um es auf dem Pi mit der richtigen Hardware zu testen.

=== Remote Host in IntelliJ
Um Ihren Raspberry Pi als Remote Host in IntelliJ einzurichten, müssen Sie zuerst in der Menüleiste die folgendenden Menüpunkte wählen:  _"Tools" -> "Deployment" -> "Browse Remote Host"_

Jetzt erscheint ein neues Menü auf der rechten Seite, wo sich auch normalerweise  die gradle und Datenbank Einstellungen befinden. 

Klicken Sie in diesem Menü auf die 3 Punkte, um einen neuen Server zu erstellen. Der Name spielt hierbei keine Rolle, aber der Typ sollte SFTP sein. Bestätigen Sie dann ihre Eingabe.

Nun können Sie die Einstellung für das Raspberry Pi im Deployment Fenster angeben:

. Geben Sie zuerst die IP-Adresse des Raspberry Pis an

. Hier können Sie die Connection mit dem Usernamen und dem Passwort einmal ausprobieren, bevor Sie es hinzufügen.

. Nach dem Connection-Test können Sie auf das kleine Ordner Symbol klicken, um auf die Ordner Struktur des Raspberry Pis zu zugreifen. Wählen Sie hier den Ort, an dem Alle Files des Projekts hinkopiert werden sollen.

. Sie können mehrere Server hinzufügen, für die einfache Verwendung in verschiedenen Netzwerken


._Remote Host Server Einstellungen_
image::./installation/RemoteHost3.png[width=75% remote host server settings]

Jetzt können Sie jeder Zeit alle Dateien oder einzelne ausgewählte Dateien mit im Remote Host Menü auf den Raspberry Pi übertragen.

Auf dem Pi selbst müssen Sie dann nur noch ihr Projekt bauen und ausführen, aber für die Entwicklung geniessen Sie alle Vorzüge der IDE auf ihrem Rechner.

._Update Remote Host_
image::./installation/RemoteHost4.png[width=75% update remote host server]

=== Optional: Remote Debugging
Es ist auch möglich den Code vom eigenen Rechner aus mit IntelliJ auf dem Raspberry Pi auszuführen und diesen auf dem eigenen Rechner zu debuggen. Diese Funktionalität kann sehr hilfreich sein, wenn man mit schwierigen Bugs zu tun hat, aber birgt auch Schwierigkeiten und funktioniert auch nicht immer ideal, deshalb wurde dieser Bereich als optional deklariert.

Wenn Sie ein schweres Problem haben und sich das Debugging aber erleichtern wollen, dann ist es empfehlenswert diese Funktionalität auszuprobieren.

*Setup*

. Downloaden Sie das folgende Plugin von Jetbrains:  + 
https://plugins.jetbrains.com/plugin/7738-embedded-linux-jvm-debugger-raspberry-pi-beaglebone-black-intel-galileo-ii-and-several-other-iot-devices-[Embedded Linux JVM Debugger]


. Fügen Sie eine Run/ Debug Configuration hinzu vom Typ Embedded Linux JVM, wie im Bild weiter unten ersichtlich. Ersetzten Sie einfach die IP-Addresse und die Projektinformationen mit denen von Ihnen. + 


._Embedded JVM Configuration_
image::./installation/RemoteDebugging.png[width=75% Remote Debuggging Configuration]

Für  weitere Informationen zum Remote Debugging mit IntelliJ auf dem Raspberry Pi können Sie den folgenden Artikel studieren: + 
https://medium.com/@menchukanton/setup-intellij-idea-for-remote-debugging-java-code-on-a-raspberry-pi-6e9df09dfb95[Remote debugging java code on a Raspberry Pi]

== Beispiele
In diesem Kapitel finden Sie für eine Vielzahl an gängigen Sensoren und Aktuatoren Code Beispiele sowie Beispiele zur Verkabelung. Für ein vollständiges Verständnis der Code Beispiele sind gewisse Vorkenntnisse von Nöten. Wir haben die Beispiele deshalb in Levels eingeteilt, an welchen Sie den Grad an nötigen Vorkenntnissen einfach erkennen können.

* *Level 1: Basic*
    ** Variablen und Berechnungen: primitive Datentypen, Wertebereiche und deren Auswirkung beim Rechnen.
    ** Methoden und Parameter: Deklaration, Aufruf, Signatur, Argumente und Rückgabewerte.
    ** Kontrollstrukturen: Schleifen und Fallunterscheidungen.
    ** Grundlagen Klassen, Objekte und Vererbung: Deklaration und Instanziierung von Klassen, Überladen und Überschreiben von Methoden, Vererbung, Polymorphie.
* *Level 2: Intermediate*
    ** Verwendung grundlegender Datenstrukturen (List, Map, Set) und Iteratoren.
    ** Generics und ihre Besonderheiten in Java.
    ** Event Handling.
    ** Collection-Streams und Lambda-Ausdrücke.
* *Level 3: Advanced*
    ** Nebenläufigkeit mit Threads.
    ** Strukturierung von Applikationen.
    ** Daten-Persistenz (File-Handling, Serialisierung).

=== Blink LED
==== Verkabelung

Für die Verkabelung wird folgende Hardware benötigt:

* 2x Kabel
* 1x LED
* 1x 220Ω Wiederstand

.LED Verkabelung 
image::./fritzing/blink_led.png[width=75% LED Wiring]

==== Code Beispiel
Die blinkende LED ist das "Hello World"-Äquivalent der GPIO Programmierung. Mit dem nachfolgenden Code lassen wir eine LED im Abstand von einer Sekunde blinken.

===== GPIO Beispiel
*Vorkenntnisse: Basic*
[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/BlinkLed.java[tags=BlinkLed]
----
===== Device Beispiel
*Vorkenntnisse: Advanced*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/BlinkLedDevice.java[tags=BlinkLedDevice]
----

=== Button Click
==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 4x Kabel
* 1x Button
* 1x 220Ω Wiederstand

.Button Verkabelung 
image::./fritzing/button_click.png[width=75% Button Wiring]

==== Code Beispiel
In diesem Beispiel wird jeder Klick auf dem Button in der Konsole angezeigt.

===== GPIO Beispiel
*Vorkenntnisse: Basic*
[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/ButtonClick.java[tags=ButtonClick]
----

===== Device Beispiel
*Vorkenntnisse: Intermediate*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/ButtonClickDevice.java[tags=ButtonClickDevice]
----


=== LCD I2C
==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 4x Kabel
* 1x LCD1602 I2C Modul mit PCF8574 I2C extender

.LCD I2C Modul Verkabelung 
image::./fritzing/LCDI2C.png[width=75% I2C Wiring]

==== API
TODO

==== Anwendungsbeispiel

In diesem Code Beispiel wird der Titel des Projekts in der ersten Zeile angezeigt und die Uhrzeit in der Zweiten. Die Uhrzeit wird im Sekundentakt aktualisiert. +
*Vorkenntnisse: Basic*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/LcdSystemTimeI2C.java[tags=LcdSystemTimeI2C]
----

=== DC Motor
Gleichstrommotoren arbeiten, wie der Name schon verrät, mit Gleichstrom. Da der Raspberry Pi Gleichstrom mit 3.3 Volt sowie 5.0 Volt zur Verfügung stellt, können die Motoren direkt an den Stromkreis des Pi angeschlossen werden. Alternativ kann auch eine stärkere, externe Spannungsquelle verwendet werden. Dabei gilt aber zu beachten, dass der Motor nicht überlastet wird.

Um einen DC Motor zu kontrollieren, benötigt man einen Motor Treiber. Wir haben dazu den Chip L293D verwendet. Natürlich kann auch ein anderer Treiber verwendet werden.

* Das Pinout des L293D findet ihr unter folgendem Link oder in diesem Dokument unter Zusatzinformationen.: https://components101.com/l293d-pinout-features-datasheet
* Dieses Youtube Video von Gaven MacDonald zeit auf, wie ein DC Motor über GPIO Pins gesteuert werden kann. Ab der Minute 2 wird genauer auf den Treiber L293D eingegangen. https://www.youtube.com/watch?v=W7cV9_W12sM

.Motor und Treiber
image::./motor_and_driver.png[width=75% DC Motor and Driver]

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x DC Motor
* 1x L93D Treiber
* 10x Kabel

.DC Motor Verkabelung
image::./fritzing/motor.png[width=75% DC Motor Fritzing]

==== API
.Motor - Konstruktoren
[cols="1,1"]
|===
|Konstruktor |Beschreibung
|MotorComponent(com.pi4j.util.Console console, com.pi4j.io.gpio.GpioPinDigitalOutput forwards, com.pi4j.io.gpio.GpioPinDigitalOutput backwards) | Constructor of the MotorComponent. This constructor allows controlling the motors direction using digital output pins.
|MotorComponent(com.pi4j.util.Console console, com.pi4j.io.gpio.GpioPinPwmOutput forwards, com.pi4j.io.gpio.GpioPinPwmOutput backwards) | Constructor of the MotorComponent. This constructor allows controlling the motors direction and speed using hardware or software PWM output pins.
|===

.Motor - Funktionen
[cols="1,2,2"]
|===
|Rückgabetyp |Funktion |Beschreibung
|void |moveBackwards() | Runs the motor run backwards at full speed.
|void |moveBackwards(int power) |Runs the motor backwards at a specific speed.
|void |moveForwards() |Runs the motor run forwards at full speed.
|void |moveForwards(int power) |Runs the motor forwards at a specific speed.
|void |stop() |Stops the motor.
|===

==== Anwendungsbeispiel
Das Code Beispiel erzeugt ein neues `MotorComponent`. Bei der Erstellung wird jener Konstruktor benutzt, welcher PWM Pins unterstützt. Dieser erlaubt die Drosselung der Drehzahldes Motors.

In einer While-Schlaufe wird die Drehzahl des vorwärts drehenden Motors schrittweise um 10% erhöht. Nachdem 100% Leistung erreicht wurde, stoppt der Motor für 5 Sekunden. Anschliessend wird die Drehrichtung des Motors umgekehrt. Der Motor dreht nun rückwärts und die Drehzahl wird wiederum schrittweise um je 10% inkrementiert.


[source,java]
----
include::{sourcedir}/fhnwexamples/component/MotorDevice.java[tags=MotorDevice]
----

=== Potentiometer
Ein Potentiometer ist eine Art dynamischer Wiederstand, welcher durch das Drehen oder Verschieben eines Reglers vergrössert oder verkleinert werden kann. Der Grove Potentiometer gibt uns je nach eingestelltem Wiederstand einen Wert zwischen 0 und 1'000 zurück. Mit einem Potentiometer können wir also Werte einstellen, mit welchen wir dann einen Aktuator kontrollieren können. Zum Beispiel könnten wir mit einem Potentiometer die Helligkeit einer Leuchtdiode steuern.

.Grove Potentiometer
image::./Grove_Rotary_Angle_Sensor.jpg[width=75% Grove Rotary Angle Sensor]

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Grove Potentiometer mit Grove Adapter Kabel

.Grove Potentiometer Verkabelung
image::./fritzing/Grove_Base_Hat_Rotary_Angel_Sensor.jpg[width=75% Grove Rotary Angle Sensor Fritzing]

==== API
.Potentiometer - Konstruktoren
[cols="1,1"]
|===
|Konstruktor |Beschreibung
|PotentiometerComponent(GroveAdapter groveAdapter) |Constructor of the PotentiometerComponent with Grove adapter.
|===

.Potentiometer - Funktionen
[cols="1,2,2"]
|===
|Rückgabetyp |Funktion |Beschreibung
|int |getValue() |Get the current value from the potentiometer.
|void |setRange(int minValue, int maxValue) |Set the value returned by getValue() to a specific range. The difference between minValue and MaxValue must be between 10 and 999.
|===

==== Anwendungsbeispiel
Das Code Beispiel erzeugt ein neues `PotentiometerComponent`, welches am Grove Base Hat am analogen Adapter A0 anliegt. Mit der `setRange()` Funktion wird sichergestellt, dass die zurückgegebenen Werte zwischen 0 und 100 liegen. Der aktuelle Wert wird alle 500 Millisekunden geloggt.

[source,java]
----
include::{sourcedir}/fhnwexamples/component/PotentiometerDevice.java[tags=PotentiometerDevice]
----

=== Serial Camera
Die Grove Serial Camera besteht aus einem Kamera Modul und einem Control Board, welches die Kommunikation zwischen der Kamera und dem Raspberry Pi über den Serial Bus ermöglicht. Die Kamera benötigt eine Spannung von 5 Volt, weshalb sie leider nicht mit unserem Grove Hat kompatibel ist. Dieser liefert nur 3.3 Volt an die Grove Adapter. Um die Kamera dennoch nutzen zu können, muss sie via Jumper Kabel an den Serial Port des Raspberry Pi angeschlossen werden. Weitere Informationen zur Verkabelung können dem Tutorial entnommen werden.

.Grove Serial Camera
image::Grove_Serial_Camera.jpg[width=75% Grove Serial Camera]

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Grove Serial Camera mit Grove Adapter Kabel
* 4x Kabel

.Serial Camera Verkabelung
image::./fritzing/grove_serial_cam.png[width=75% Grove Serial Camera Fritzing]

==== API
.Serial Camera - Konstruktoren
[cols="1,1"]
|===
|Konstruktor |Beschreibung
|SerialCameraComponent(com.pi4j.util.Console console) |Constructor of the SerialCameraComponent without logging and a default package size of 512 bytes.
|SerialCameraComponent(com.pi4j.util.Console console, boolean activateLogging) |Constructor of the SerialCameraComponent with a default package size of 512 bytes.
|SerialCameraComponent(com.pi4j.util.Console console, int packageSize) |Constructor of the SerialCameraComponent without logging.
|SerialCameraComponent(com.pi4j.util.Console console, int packageSize, boolean activateLogging) |Constructor of the SerialCameraComponent.
|===

.Serial Camera - Funktionen
[cols="1,2,2"]
|===
|Rückgabetyp |Funktion |Beschreibung
|byte[] |getImageAsJpgBytes() |This method request a jpg image of the camera and returns it as a byte array.
|java.lang.String |saveImageAsJpg(java.lang.String fileName) | Requests a jpg image from the camera and streams it to a file.
|java.lang.String |saveImageAsJpg(java.lang.String relativePath, java.lang.String fileName) |Requests a jpg image from the camera and streams it to a file.
|===

==== Anwendungsbeispiel
Das unten abgebildete Code Beispiel zeigt, wie mit der Hilfe unserer SerialCameraComponent ein JPEG Foto geschossen und unter einem bestimmten Pfad abgespeichert werden kann.

[source,java]
----
include::{sourcedir}/fhnwexamples/component/SerialCamera.java[tags=SerialCamera]
----

=== Raspberry Pi Camera
Die Raspberry Pi Camera ist die Camera Komponente, welche standardmässig vom Pi unterstützt wird. Es ist eine kleine 8MP Kamera, die über ein Flachbandkabel direkt an den Pi angeschlossen werden kann. Man kann 3280 x 2464 Pixel für Bilder verwenden und 1080p mit 30fps/ 720p mit 60fps/ 640x480p mit 90fps für Videos.

.Raspberry Pi Camera
image::./RaspberryPi_Camera.jpg[width=70% RaspiCam]

Für die Verwendung muss sie aber zunächst im OS aktiviert werden. Unter den Interfacing Options, von raspi-config können Sie es problemlos aktivieren. 

.Raspberry Pi Camera aktivieren
image::./RaspberryPi_Camera_Activation.jpg[width=60% activate RaspiCam]

Rasbian OS enthält auch Applikationen, welche sie nutzen können, um die Camera in der Console zu testen.

Starten Sie ihr Terminal und geben sie folgenden Befehl ein:

[source,java]
----
raspistill -o /home/pi/Pictures/image.jpg
----

Jetzt sollten Sie ein Bild im Standardverzeichnis für Bilder finden können.

Für mehr Informationen über die Befehle können Sie den Zusatzinformationsteil für die Raspberry Pi Camera anschauen -> 
<<Terminal Befehle>>

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Raspberry Pi Camera mit Flachbandkabel

.Raspberry Pi Camera Verkabelung 
image::./fritzing/raspiCam.png[width=60% RaspiCam Wiring]

==== API
TODO

==== Anwendungsbeispiel
In diesem Code Beispiel wird die Raspberry Pi Camera mit der `RaspberryPiCameraComponent` verwendet, um zwei Bilder und ein Video aufzunehmen in den Ordner `/home/pi/Pictures/`.  +
*Vorkenntnisse: Intermediate*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/RaspberryPiCamera.java[tags=RaspberryPiCamera]
----

=== Grove RFID Reader
Der Grove RFID Reader ist ein 125KHz RFID Reader, welches uem4100 RFID Karteninformationen seriell lesen kann. Die maximale Distanz zum Lesen beträgt 70mm. Die RFID Reader benötigt eine Spannung von 5 Volt, weshalb es nicht mit dem Grove Hat kompatibel ist, da dieser nur 3.3 Volt liefert. Es ist jedoch möglich es mit Kabeln direkt an den Pi zu verbinden, wie bei der Grove Serial Camera.

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Grove RFID Reader mit Grove Adapter Kabel
* 4x Kabel

.Serial Camera Verkabelung
image::./fritzing/grove_rfid_reader.png[width=75% Grove RFID Reader Fritzing]

==== API
TODO

==== Anwendungsbeispiel
In diesem Code Beispiel wird der Grove RFID Reader getestet. Das serielle Gerät wird initialisiert und ein Listener wird hinzugefügt, der die `dataReceived()` Methode des `SerialDataEventListener` überschreibt. Diese Methode wird immer ausgeführt, wenn der RFID Reader Daten durch einen RFID Tag erhält. +
*Vorkenntnisse: Intermediate*
[source,java]
----
include::{sourcedir}/fhnwexamples/component/RFIDReader.java[tags=RFIDReader]
----

=== Servo Motor

=== Stepper Motor
Der Stepper Motor oder Schrittmotor rotiert die in seiner Mitte liegende Welle in Schritten. Die Welle eines Schrittmotors dreht sich im Vergleich zu jener eines Gleichstrommotors sehr langsam. Dafür kann der Schrittmotor sehr genau gesteuert werden. Je nach eingestelltem Modus variiert die Anzahl der Schritte, welche für eine gesamte Drehung benötigt werden. Der Modus beeinflusst auch die Kraft, welcher der Motor hat und hat Zusammenhang mit dem resultierenden Energieverbrauch des Motors.

In der unten abgebildeten Tabelle beziehen wir uns auf den weit verbreiteten Schrittmotor 28BYJ-48. Eine Drehung des Zylinders innerhalb des Motors resultiert in einer Drehung der Welle um 11.25°. Für eine Komplette Drehung werden also 360° / 11.25° = 32 Schritte benötigt. Ein Getriebe innerhalb des Motors reduziert einen einzelnen Schritt in weitere 64 Steps. Unter Verwendung des Full oder Dual Stepping bedeutet ein einzelner Step also eine Drehung um 360° / (32 * 64) = 0.17578125°. Bei Half Stepping verdoppelt sich die Anzahl der möglichen Schritte, was eine Drehgenauigkeit von 0.087890625° zulässt.

.Stepper Motor Modi
[cols="1,2,1,1,1"]
|===
|*Typ* |*Enum Attribut* | *Schritte pro 360°* |*Energie* | *Kraft*
|Half Stepping |StepperMotorMode.HALF_STEP |4096 | ca. 1.5x | 90% bis 100%
|Single Stepping |StepperMotorMode.SINGLE_STEP |2048 |1x | 100%
|Dual Stepping |StepperMotorMode.DOUBLE_STEP |2048 |2x | 130% bis 140%
|===

Auf YouTube findet ihr ein sehr informatives Video von Gaven MacDonald über die Funktionsweise eines Stepper Motors. https://www.youtube.com/watch?v=Dc16mKFA7Fo

.Stepper Motor Verkabelung 
image::./stepper_motor_and_driver.png[width=75% RaspiCam Wiring]

==== Verkabelung
Für die Verkabelung wird folgende Hardware benötigt:

* 1x Steper Motor
* 1x ULN2003APG Stepper Treiber
* 8x Kabel

.Stepper Motor Verkabelung 
image::./fritzing/stepper_motor.png[width=75% RaspiCam Wiring]

==== API
.Stepper Motor - Konstruktoren
[cols="1,1"]
|===
|Konstruktor |Beschreibung
|StepperMotorComponent(com.pi4j.util.Console console, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut1, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut2, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut3, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut4) |Constructor which uses the default value of 2 milliseconds for the step delay and the default stepper motor mode 'SINGLE_STEP'.
|StepperMotorComponent(com.pi4j.util.Console console, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut1, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut2, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut3, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut4, int stepDelay) |Constructor which uses the default value 'SINGLE_STEP' for the stepper motor mode.
|StepperMotorComponent(com.pi4j.util.Console console, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut1, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut2, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut3, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut4, int stepDelay, StepperMotorMode mode) |Constructor which allows to specify all the different Parameters.
|StepperMotorComponent(com.pi4j.util.Console console, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut1, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut2, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut3, com.pi4j.io.gpio.GpioPinDigitalOutput digitalOut4, StepperMotorMode mode) |Constructor which uses the default value of 2 milliseconds for the step delay.
|===

.Stepper Motor - Funktionen
[cols="1,2,2"]
|===
|Rückgabetyp |Funktion |Beschreibung
|StepperMotorMode |getMode() |
|int |getStepDelay() |Getter of the step delay value.
|void |	setMode(StepperMotorMode mode) |Setter of the stepper motor mode value.
|void |setStepDelay(int stepDelay) |Setter of the step delay value.
|void |stepBackwards(int steps) |Step the stepper motor backwards using the currently set mode for a specific amount of steps.
|void |stepForwards(int steps) |Step the stepper motor forwards using the currently set mode for a specific amount of steps.
|void |stop() |This methods stops the motor and clears the magnetic field.
|===

==== Anwendungsbeispiel
Das unten abgebildete Beispiel zeigt die Verwendung der verschiedenen Stepper Motor Modi. Das Beispiel verwendet den Konstruktor mit den meisten Default Values. Die Step Delay beträgt also 2 Millisekunden und der Modus wird initial auf `StepperMotorMode.SINGLE_STEP` gesetzt. Nach der Initialisierung wird der Motor in den verschiedenen Modi vorwärts und zurück gedreht. Vor jedem Wechsel in einen anderen Modus wird fünf Sekunden gewartet.

[source,java]
----
include::{sourcedir}/fhnwexamples/component/StepperMotorDevice.java[tags=StepperMotorDevice]
----

== Zusatzinformationen

=== Grove Serial Camera
Die Grove Serial Camera ist eines der komplexeren Devices, welches von unserer Library unterstützt wird. Zur Kommunikation über den Serial Bus wird ein spezielles Protokoll eingesetzt. In den folgenden Unterkapiteln finden Sie weitere Informationen zu jenem Protokoll und unserer Implementation davon.

==== Protokoll
Die Datenübermittlung zwischen Kamera und Pi erfolgt über den Serial Bus und das OV528 Protokoll. Die einzelnen Kommandos umfassen jeweils 6 Bytes, welche zusammen als Paket übermittelt werden. Das nachfolgende Beispiel zeigt das SYNC Kommando, welches jeweils zu Beginn der Kommunikation vom Pi ausgesendet wird. Folgende Bytes werden übermittelt: AA0D00000000h.

.SYNC Kommando
image::Grove_Serial_Camera_SYNC_Command.png[500, 500, Grove Serial Camera SYNC]

==== Verbindung mit der Kamera aufbauen
Bevor Befehle an die Kamera gesendet werden können, muss eine Verbindung zwischen Kamera und Raspberry Pi etabliert werden. Dazu wird vom Host mehrmals ein SYNC Kommando auf den Serial Port geschrieben und auf eine Antwort von der Kamera gewartet. Durchschnittlich antwortet die Kamera nach 25 SYNC Kommandos mit einem ACK (AA0E0Dxx0000h). Auf die Empfangsbestätigung folgt das Kommando, welches die Kamera bestätigt. In diesem Fall das SYNC Kommando (AA0D00000000h). Gibt die Kamera nach 60 SYNC Befehlen noch immer keine Antwort, kann davon ausgegangen werden, dass etwas mit der Verkabelung der Kamera nicht stimmt oder der Controller der Kamera defekt ist.

.Verbindungsaufbau
image::Grove_Serial_Camera_Initialisation.png[500, 500, Grove Serial Camera Connection]

In unserer Java Klasse haben wir den Verbindungsaufbau in einer eigenen Funktion realisiert, welche vom jeweiligen Konstruktor aufgerufen wird. In einer While-Schlaufe wird das SYNC Kommando solange an die Kamera gesendet, bis diese eine Antwort auf den Serial Bus geschrieben hat. Ist dies nach 60 Versuchen nicht der Fall, wird die Initialisierung mit einem Fehler abgebrochen. Hat die Kamera eine Antwort gesendet, wird diese auf Ihre Korrektheit überprüft. Die ersten sechs Bytes müssen dem ACK Kommando entsprechen (AA0E0Dxx0000h). Bei den nächsten sechs Bytes muss es sich um das SYNC Kommando handeln (AA0D00000000h). Sofern dies der Fall ist, war der Verbindungsaufbau erfolgreich. Die Kamera ist nun bereit für die Entgegennahme von weiteren Befehlen.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/SerialCameraComponent.java[tags=SerialCamInit]
----

==== JPEG Foto anfordern
Nach dem erfolgreichen Verbindungsaufbau ist die Kamera bereit für das Schiessen von Bildern. Unsere Implementation stellt Bilder im JPEG Format in der Auflösung 640 x 480 zur Verfügung. Hierbei handelt es sich um die maximale Auflösung der Kamera. Theoretisch können auch Bilder in anderen Grössen und Formaten von der Kamera angefordert werden. Diese Formate werden von uns jedoch nicht unterstützt.

Um ein Bild von der Kamera zu erhalten, sind mehrere einzelne Schritte, Befehle und Bestätigungen nötig. Diese sind im folgenden Diagramm ersichtlich.

.Ablauf der Bildanforderung
image::Grove_Serial_Camera_Get_Picture.png[500, 500, Grove Serial Camera Get Picture]

==== Bildgrösser ermitteln
Zur Ermittlung der Bildgrösse wird die gewünschte Paketgrösse der einzelnen Pakete benötigt. Die Paketgrösse kann vom Anwender im Bereich von 16 bis 2048 Bits definiert werden. Die Default Paketgrösse ist 512 Bits.

Als erster Schritt wird die zuvor definierte gewünschte Paketgrösse an die Kamera gesendet und es wird auf eine Empfangsbestätigung der Kamera gewartet.

Anschliessend wird das Snapshot Kommando an die Kamera gesendet. Dieses Kommando bereitet die Kamera auf das Erzeugen eines Bildes vor. Auch hier wird wieder auf eine Empfangsbestätigung der Kamera gewartet.

Zu guter Letzt wird der Befehl zur JPEG Generierung an die Kamera übermittelt. Die Kamera antwortet auf dieses Kommando mit einer Empfangsbestätigung gefolgt von der Anzahl Bytes des Bildes, welches geschossen wurde.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/SerialCameraComponent.java[tags=SerialCamGetPictureLength]
----

==== Bild Pakete empfangen
Nachdem die Bildgrösse von der Kamera ermittelt wurde, kann der Host Paket für Paket von der Kamera über den Serial Bus anfordern. Wir fordern solange Pakete von der Kamera an, bis wir das letzte Paket von der Kamera erhalten haben. Das letzte Paket erkennen wir anhand der letzten zwei Bytes. Handelt es sich bei diesen um 0xFF gefolgt von 0xD9, wurde das komplette JPEG übermittelt. Bei den zwei Bytes handelt es sich nämlich um den Footer eines jeden JPEGs.

Da es bei der Übermittlung von Paketen immer zu Fehlern kommen kann, stellt das OV528 Protokoll einen Kontrollmechanismus zur Verfügung, über welchen Fehler identifiziert werden können. Bei den zwei letzten Bytes eines jeden Pakets handelt es sich um eine Prüfsumme, mit welchen die übermittelten Bilddaten überprüft werden können. Die Prüfsumme muss exakt der Summe der einzelnen übermittelten Bytes entsprechen. Ist dies der Fall, fordern wir das nächste Paket von der Kamera an. Stimmt die Prüfsumme jedoch nicht mit der Summe aller Bild-Bytes überein, fordern wir das fehlerhafte Paket erneut von der Kamera an. Damit kann sichergestellt werden, dass das erhaltene Bild immer fehlerfrei ist.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/SerialCameraComponent.java[tags=SerialCamGetPicture]
----

=== Potentiometer
Das Grove Potentiometer wird über einen der analogen Ports an den Grove Base Hat angeschlossen. Der Grove Base Hat stellt die gelesenen oder zu schreibenden Werte über den I2C Bus dem Raspberry Pi zur Verfügung.

==== Konstruktor
Die `PotentiometerComponent` Klasse erweitert die von uns implementierte `I2CBase` Basisklasse. Im Konstruktor wird die I2C Adresse des analogen Potentiometers zusammen mit der zu verwendenden Bus Nummer an die Basisklasse weitergeleitet. Da der Raspberry Pi nur einen I2C Bus besitzt, wird immer dieser Bus übergeben.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/PotentiometerComponent.java[tags=PotentiometerComponentConstructor]
----

==== Wertebereich setzen
Der Grove Potentiometer liefert uns über den I2C Bus je nach eingestellter Position einen Wert zwischen 0 und 1000. Mittels der `setRange()` Funktion kann der Rückgabewert eingeschränkt werden. Erlaubt sind nur positive Integer dessen Differenz mindestens 10 beträgt und nicht grösser als 999 ist.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/PotentiometerComponent.java[tags=PotentiometerComponentSetRange]
----

==== Value lesen
Der aktuelle Value des Potentiometers kann über die `getValue()` Funktion gelesen werden. Dazu verwenden wird die `readData()` Funktion unserer Basisklasse. Wir erwarten zwei Bytes auf dem Bus, welche über eine Hilfsfunktion in ein Integer Wert konvertiert werden. Der gelesenen Integer wird gemäss dem eingestellten Range zurückgegeben.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/PotentiometerComponent.java[tags=PotentiometerComponentGetValue]
----

=== DC Motor
Gleichstrommotoren können mittels dem ihnen zur Verfügung gestellten Strom in ihrer Drehrichtung und Drehzahl reguliert werden. Diese Eigenschaft haben wir uns zu Nutzen gemacht, um unsere Component Klasse zu implementieren.

==== Motor Treiber L293D
Der Chip erlaubt uns das Anpassen der Drehrichtung von Gleichstrommotoren mit einer Spannungsaufnahme von bis zu 36 Volt. Jede Seite des Chips erlaubt die Kontrolle eines Motors. Mit einem einzelnen L293D können also gleich zwei Motoren individuell angesteuert werden. Die folgende Abbildung zeigt das Pinout des Chips gefolgt von einer Beschreibung der einzelnen Pins.

.Pinout L293D
[link=https://components101.com/l293d-pinout-features-datasheet]
image::L293D_Pinout.png[width=75% L293D Pinout]

.Beschreibung Pinout
[cols="1,2,4"]
|===
|Pin Nummer |Pin Name |Beschreibung
|1 |Enable 1, 2 |Aktiviert Input 1 und 2 wenn 5V Spannung anliegt.
|2 |Input 1 |Kontrolliert Output 1. Muss mit einem Controller verbunden werden.
|3 |Output 1 |Wird mit dem Motor 1 verbunden.
|4 |Ground |-
|5 |Ground |-
|6 |Output 2 |Wird mit dem Motor 1 verbunden.
|7 |Input 2 |Kontrolliert Output 2. Muss mit einem Controller verbunden werden.
|8 |Vcc 2) |Stromlieferant für den Motor / die Motoren. Positiver Pol der Stromquelle.
|9 |Enable 3. 4 |Aktiviert Input 3 und 4 wenn 5V Spannung anliegt.
|10 |Input 3 |Kontrolliert Output 3. Muss mit einem Controller verbunden werden.
|11 |Output 3 |Wird mit dem Motor 1 verbunden.
|12 |Ground |-
|13 |Ground |-
|14 |Output 4 |Wird mit dem Motor 1 verbunden.
|15 |Input 4 |Kontrolliert Output 4. Muss mit einem Controller verbunden werden.
|16 |Vcc 1 |Spannungsquelle für die Logik des Chips. Hier müssen 5V angelegt werden.
|===

==== Drehrichtung wechseln
Wie bereits erwähnt, kann die Drehrichtung des Gleichstrommotors mittels Umkehrung der Polarität der Spannungsquelle gewechselt werden. Dies ist mittels des Motor Treibers L293D sehr einfach möglich. Die Polarität der Output Pins können wir mittels des Setzens der Input Pins beeinflussen. Die untere Tabelle zeigt, wie wir die verschiedenen Drehrichtungen umgesetzt haben. In unserem Beispiel verwenden wir die linke Seite des Chips. Enable 1, 2 ist also aktive, Enable 3, 4 ist inaktiv.

.Beschreibung Pinout
[cols="1,1,1"]
|===
|*Input 1* |*Input 2* |
|High |Low |Motor dreht sich im Uhrzeigersinn.
|Low |High |Motor dreht sich im Gegenuhrzeigersinn.
|Low |Low |Motor stoppt.
|===

Das nachfolgenden Code Beispiele zeigt die `moveForwards()` sowie die `stop()` Funktion unserer Motor Component. Dabei wird unterschieden, ob der Motor zusätzlich über PWM gesteuert wird oder nicht. Dazu aber mehr im nächsten Unterkapitel.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/MotorComponent.java[tags=MotorComponentMoveForwards]
----

[source,java]
----
include::{sourcedir}/fhnwgpio/components/MotorComponent.java[tags=MotorComponentStop]
----

==== Geschwindigkeit anpassen
Bei der Steuerung der Geschwindigkeit kann uns der Motor Treiber Chip nicht unterstützen. Dennoch kann die Geschwindigkeit des Motors manipuliert werden. Dies geschieht generell durch die Anpassung der am Motor anliegenden Spannung. Das Werkzeug unserer Wahl ist deshalb die **P**ulse **W**idth **M**odulation Funktion des Raspberry Pi.

*PWM* lässt es zu, Pins gemäss einem gewissen Rhythmus zwischen High und Low wechseln zu lassen. Beispielsweise können wir einen Pin in einer Frequenz von 50 Hertz zwischen On und Off wechseln lassen. Zusätzlich können wir pro Puls bestimmen, wie lange der Pin High ist, bevor er zu Low wechselt. Dies nennen wir den Duty Cycle. Über den Duty Cycle steuern wir die am Motor anliegende Spannung und somit die Geschwindigkeit des Motors. Ein Duty Cycle von 0% entspricht dem Stillstand des Motors. 25% Duty Cycle entspricht einer Drehgeschwindigkeit von 25%. 100% Duty Cycle entspricht der vollen Leistung des Motors.

.PWM als Grafik
[link=https://www.elektronik-kompendium.de/sites/kom/0401111.htm]
image::pwm.png[width=75% L293D Pinout]

In unserer Component Klasse steuern wir den Duty Cycle über die GPIO Klasse von Wiring Pi. Der gewünschte Duty Cycle wird über die `setPWM()` Funktion festgelegt. Die `rangeAdjustment` Variable wird benötigt, da Wiring Pi zwischen Software und Hardware PWM Pins unterscheidet.

* **Software:** Duty Cycle zwischen 0 und 100
* **Hardware:** Duty Cycle zwischen 0 und 1024

Der Raspberry Pi stellt 2 Hardware PWM Pins zur Verfügung. Dabei handelt es sich um die BCM Pins 12 und 13. Werden diese Pins an den Konstruktor übergeben, wird die Hardware PWM Funktionalität des Pi verwendet.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/MotorComponent.java[tags=MotorComponentMoveForwardsPwm]
----

=== Stepper Motor
https://www.rs-online.com/designspark/stepper-motors-and-drives-what-is-full-step-half-step-and-microstepping

<<<

=== Raspberry Pi Camera
Die Raspberry Pi Camera enthält in Rasbian vier Applikationen, welche man vom Terminal aus verwenden kann.

* `raspistill` und `raspiyuv` für die Bildaufnahme
* `raspivid` und `raspividyuv` für die Videoaufnahme

`raspiyuv` und `raspividyuv` verwenden keinen Encoder, sondern senden ihr YUV (Ein Farbmodell wie RBG) direkt von der Kamera an ein File. Diese beiden Applikationen werden nicht unterstützt von der `RaspberryPiCameraComponent`. Die Device Klasse verwendet intern nur `raspistill` und `raspivid`. 

In den folgenden Unterkapiteln wird auf die Terminal Befehle für `raspistill` und `raspivid` eingegangen, falls es direkt verwendet wird. Ausserdem wird auf die Funktionalität der `RaspberryPiCameraComponent` eingegangen.

==== Terminal Befehle
Hier sind einige Beispiele für Standardbefehle mit `raspistill`:

* Bildaufnahme (default) + 
`raspistill -o image.jpg`

* Aufnahme in anderen Formaten z. B: jpg, bmp, gif und png + 
`raspistill –e png -o image.png`

* Zeitverzögerte Aufnahme mit -t _<Millisekunden>_ + 
`raspistill  -t 2000 -o image.jpg`

* Aufnahme in einer anderen Auflösung + 
`raspistill  -w 640 -h 480 -o image.jpg`

* Aufnahme in einer niedrigeren Qualität (In Prozent)
`raspistill -q 50 -o image.jpg`

Hier sind einige Beispiele für Standardbefehle mit `raspivid`:

* 15 Sekunden Video mit default Einstellungen (1080p, also 1920 x 1080 und 30 fps) + 
`raspivid  -t 15000 -o video.h264`

* 15 Sekunden Video in 720p (1280 x 720) + 
`raspivid -t 15000 -w 1280 -h 720 -o video.h264`

* 15 Sekunden Video mit 10 Frames/Sekunde
`raspivid -t 10000 -f 10 -o video.h264`

* 15-Sekunden-Video mit 3 MBits/s +
`raspivid -t 15000 -b 3000000 -o video.h264`

Für mehr Informationen können Sie die Befehle in der offiziellen Dokumentation anschauen: + 
https://www.raspberrypi.org/documentation/raspbian/applications/camera.md[Raspberry Pi Camera - Terminal Befehle]

==== Java Library für Bildaufnahme
Es gibt zwei prominente java Libraries, welche für die Bildaufnahme verwendet werden können.

* https://github.com/Hopding/JRPiCam[JRPiCam]: Verwendet eine Builder-Klasse, um die Befehle für `raspistill` aufzubauen und führt diese dann im Hintergrund mit einem Java Process aus. Es ist im Prinzip ein Wrapper für die native Applikation `raspistill`.
* https://github.com/caprica/picam[PiCam] `raspistill` benutzt eine native MMAL library für die Kamera, welche von picam direkt verwendet wird. Das macht picam wesentlich schneller als JRPiCam, da es kein externes Programm verwendet.

Für die Device-Klasse, welche wir zur Verfügung stellen, wird PiCam verwendet, da die hohe Geschwindigkeit ein immenser Vorteil ist. Falls aber Studierende die JRPiCam-Library verwenden möchten, dann werden sie auch hierfür ein Bespiel unter den RaspberryPi Camera Beispielen finden.

==== Bildaufnahme
Für die Bildaufnahme mit der `RaspberrPiCameraComponent` muss man sich zuerst ein `CameraConfiguration`-Objekt erstellen, welches praktisch den Befehl wiederspiegelt, welchen man im Terminal manuell eingeben kann.

[source, java]
----
//Create Configuration object with builder approach
CameraConfiguration config = cameraConfiguration()
    .width(1920)
    .height(1080)
    .encoding(Encoding.JPEG)
    .quality(85)
    .rotation(180);
----

Wenn man dann dieses Objekt der `RaspberrPiCameraComponent` im Konstruktor übergibt, dann kann man mit der Methode `takeStill` Bilder aufnehmen, wie im wenn man die PiCam-Library direkt verwendet.

==== Videoaufnahme
Für die Videoaufnahme gibt es eine Builder-Klasse, welche vom Syntax und der Verwendung her ähnlich aufgebaut ist, wie die `CameraConfiguration` Klasse von PiCam.

So wie mit der `CameraConfiguration` von der PiCam ein `raspistill` Befehl aufgebaut wird, wird mit der `RaspiVidConfiguration` dann ein `raspivid` Befehl aufgebaut.

[source, java]
----
//configuration for videos using raspivid with builder object
RaspiVidConfiguration vidConfig = new RaspiVidConfiguration()
    .verticalflip()
    .previewOff()
    .time(15000);
----

Wenn das Objekt dann der `RaspberryPiCameraComponent` übergeben wird im Konstruktor, dann wird mit der Methode `takevid` ein Video aufgenommen. Dabei wird der Befehl der Konfigurationsklasse extrahiert und als Java Process ausgeführt.

[source,java]
----
include::{sourcedir}/fhnwgpio/components/RaspberryPiCameraComponent.java[tags=RasPiCamTakeVid]
----

:sectnums!:
== TODO: Schluss

<<<
== TODO: Literaturverzeichnis
