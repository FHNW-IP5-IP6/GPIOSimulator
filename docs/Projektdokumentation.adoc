:title: Projektdokumentation GPIOSimoulator
:toc: left
:toc-title:
:toclevels: 5
:sectnums:
:sectnumlevels: 5
:sourcedir: ../src/main/java
:imagesdir: ./assets/images
:iconsdir: ./icons
:stylesdir: ./styles
:homepage: https://github.com/FHNW-IP5-IP6/GPIOSimulator

image::FHNW.png[FHNW,382,59]
[discrete]
= IP5: GPIOSimulator

*Semesterarbeit von*:

* Herr Jonathan Bättig (jonathan.baettig@students.fhnw.ch) 
* Herr Anessollah Ima (anessollah.ima@students.fhnw.ch)

*FHNW* +
*Hochschule für Technik* +
*Studiengang* : Informatik +
*Semester* : 6BB

*Betreuende Dozenten*:

* Frau Dr. Barbara Scheuner (barbara.scheuner@fhnw.ch) 
* Herr Dr. Dieter Holz (dieter.holz@fhnw.ch) 

*Datum*: 13.08.2020

[discrete]
== Management Summary
Zu Beginn war das Ziel dieser Arbeit die Entwicklung eines Hardware Simulators, mit welchem die meistverwendeten Sensoren und Aktuatoren simuliert werden können, welche häufig an den Raspberry Pi angeschlossen werden. Der Simulator sollte die Programmierschnittstellen des Raspberry Pi auf Basis der Java Library Pi4J simulieren können. Den Studierenden sollte es so ermöglicht werden, unter Verwendung von Java gegen ihren simulierten Aufbau zu programmieren und von diesem Feedback zu erhalten. Dieser Aufbau hätte die Effektivität der Teamarbeit an den IP1/2 Projekten erhöht und die Zeit, welche für die Verbindung der Hardware benötigt wird, reduziert.

Ein Grossteil dieser Arbeit beschäftigt sich mit der Frage, wieso der Simulator schlussendlich nicht im Rahmen dieser Arbeit realisiert werden konnte. Aufgrund verschiedener Hindernisse war es nicht möglich, einen Simulator zu programmieren, welcher den im Ziel definierten Nutzen bringt. Das Projekt musste sich anpassen, damit die Studierenden der ersten Semester dennoch einen Mehrwert von dieser Arbeit haben.

Anstelle des Simulators wurde eine API in Java entwickelt, welche die beliebtesten Sensoren und Aktuatoren unterstützt. Die API vereinfacht die Implementation von GPIO Projekte in Java mit dem Raspberry Pi. Neben den unabhängigen Geräten, welche an den Raspberry Pi angeschlossen werden können, ist die Library auch kompatibel mit einigen Grove Sensoren und Aktuatoren. Die Grove Sensoren und Aktuatoren können über den Grove Base Hat (ein Aufsatz für den Raspberry Pi) direkt an den Pi angeschlossen werden. Die Library und das modulare Grove System ermöglichen den Studierenden, die hardwarenahe Entwicklungszeit erfolgreich zu reduzieren. Zusätzlich wurde ein umfangreiches Tutorial erstellt, welches die Entwicklung und Verwendung der Komponentenklassen der API beschreibt. Durch das Tutorial und die zur Verfügung gestellte API wird das ursprüngliche Ziel, den Informatikstudenten die elektrotechnischen Arbeiten der GPIO Projekte zu erleichtern, erreicht. Durch die Verwendung des Tutorials und der API können sich die Studierenden besser auf die Softwareentwicklung fokussieren.

:sectnums!:
== Einleitung
In den IP1/2 Projekten der FHNW setzen die Studierenden GPIO Projekte mit dem Raspberry Pi unter Verwendung der Java Library Pi4J um. Die Studierenden arbeiten in Gruppen von 6 bis 8 Personen an individuellen Projekten. Jede Gruppe erhält einen Raspberry Pi und einige verschiedene Hardware Komponenten. Die Hardware steht also pro Gruppe lediglich einmal zur Verfügung. Allerdings sind Design und Testing stark von der Hardware abhängig. Dies hat während der Startphase immer wieder zu Verzögerungen in den Projekten der Teams geführt.

Das Ziel dieser Arbeit ist es, diese Hardwareabhängigkeit so gut wie möglich zu eliminieren. Dadurch kann der eigentliche Fokus der Projekte, die Programmierung, in den Vordergrund gerückt werden.
 
Zu Beginn sollte dieses Ziel mit einem Hardware Simulator erreicht werden. Dieser hätte es den Studierenden ermöglichen sollen, die physische Hardware durch simulierte Hardware zu ersetzen. Die Tatsache, dass Hardware nur einmal vorhanden ist, hätte die Studierenden nicht mehr gross eingeschränkt.

Ein grosser Teil dieser Arbeit beschäftigt sich mit diesem ursprünglichen Umsetzungsversuch und beschreibt, warum der geplante Simulator nicht realisiert werden konnte. Aus dem Hardware Simulator entstand eine Java-Library und ein umfangreiches Tutorial. Das ursprüngliche Ziel, den Studenten die Arbeit an den IP1/2 Projekten zu erleichtern, konnte dennoch, wenn auch in einem anderen Rahmen, erreicht werden.

:sectnums:

== Anforderungen
Die nachfolgende Tabelle enthält alle Anforderungen an den GPIO Simulator, welche wir während der Requirement Analyse identifizieren haben. Den einzelnen Anforderungen haben wir drei Prioritäten zugeteilt.

* *Priorität 1*: Anforderungen an den MVP
* *Priorität 2*: Unterstützung der Grove Sensoren
* *Priorität 3*: Implementation User Interface

Die Umsetzung der Requirements soll gemäss ihrer Priorität erfolgen.

.Anforderungen
[cols="1,7,1"]
|===
|Nummer |Beschreibung  |Priorität
|{counter:reqNumber} 
|Anwender sollen unabhängig von der Hardwareverfügbarkeit an ihren Raspberry Pi Projekten arbeiten können.
|1
|{counter:reqNumber}
|Anwender sollen auf eine einfache und intuitive Art konfigurieren können, ob der Code auf dem GPIO Simulator oder auf dem Raspberry Pi ausgeführt wird.
|1
|{counter:reqNumber}
|Anwender sollen das Logging Level des GPIO Simulators konfigurieren können, ohne dass das Projekt neu gebaut werden muss.
|1
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des Raspberry Pi via Pi4J setzen können.
|1
|{counter:reqNumber} 
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des GPIO Simulators setzen können.
|1
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des Raspberry Pi via Pi4J auslesen können.
|1
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die analogen und digitalen Pins des GPIO Simulators auslesen können.
|1
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des Raspberry Pi via Pi4J setzen können.
|2
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des GPIO Simulators setzen können.
|2
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des Raspberry Pi via Pi4J auslesen können.
|2
|{counter:reqNumber}
|Anwender sollen mittels den vom GPIO Simulator zur Verfügung gestellten Funktionen die Grove Anschlüsse des GPIO Simulators auslesen können.
|2
|{counter:reqNumber}
|Den Benutzern des GPIO Simulators sollen Code Beispiele für die gängigen Sensoren und Aktuatoren zur Verfügung stehen.
|2
|{counter:reqNumber}
|Anwender sollen vom GPIO Simulator Feedback in einem User Interface erhalten.
|3
|{counter:reqNumber} 
|Den Anwender sollen im User Interface des GPIO Simulators alle gängigen Sensoren und Aktuatoren zur Verfügung stehen.
|3
|{counter:reqNumber}
|Anwender sollen im User Interface des GPIO Simulators Sensoren und Aktuatoren mit dem Grove Hat verbinden können.
|3
|{counter:reqNumber} 
|Anwender sollen die Konfiguration der Sensoren und Aktuatoren des GPIO Simulators speichern und wiederverwenden können.
|3
|===

== Hardware
Zur Umsetzung unseres Projekts benötigen wir nebst einem Micro Computer Raspberry Pi noch diverse zusätzliche Hardware Komponenten. Dazu gehören vor allem eine Vielzahl von Sensoren und Aktuatoren. In der nachfolgenden Tabelle sind alle Komponenten festgehalten, welche uns zur Verfügung stehen.

.Micro Computer
[cols="1,7"]
|===
|Anzahl |Typ
|2 |https://www.raspberrypi.org/products/raspberry-pi-3-model-b-plus/[Raspberry Pi 3 B+^]
|===

.Freenove Box
[cols="1,7"]
|===
|Anzahl |Typ
|1 |http://www.freenove.com/index.html[Freenove Ultimate Starter Kit for Raspberry Pi] (FNK0020)
|===

.Sensoren & Aktuatoren
[cols="1,7"]
|===
|Anzahl |Typ
|1 |https://wiki.seeedstudio.com/Grove_Base_Hat_for_Raspberry_Pi/[Grove Base Hat for Raspberry Pi^]
|3 |https://wiki.seeedstudio.com/Grove-TemperatureAndHumidity_Sensor/[Grove - Temperature & Humidity Sensor^]
|3 |https://wiki.seeedstudio.com/Grove-Touch_Sensor/[Grove – Touch^]
|3 |https://wiki.seeedstudio.com/Grove-Buzzer/[Grove – Buzzer^]
|2 |https://wiki.seeedstudio.com/Grove-Magnetic_Switch/[Grove - Magnetic Switch^]
|2 |https://wiki.seeedstudio.com/Grove-Rotary_Angle_Sensor/[Grove Rotary Angle Sensor^]
|2 |https://wiki.seeedstudio.com/Grove-Gesture_v1.0/[Grove - Gesture^]
|1 |https://wiki.seeedstudio.com/Grove-Button/[Grove - Button^]
|1 |https://wiki.seeedstudio.com/Grove-Light_Sensor/[Grove – Light Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Serial_Camera_Kit/[Grove - Serial Camera^]
|1 |https://wiki.seeedstudio.com/Grove-Light-Gesture-Color-Proximity_Sensor-TMG39931/[Grove – Light & Gesture & Color & Proximity Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-I2C_Color_Sensor/[Grove - I2C Color Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Temperature_Sensor_V1.2/[Grove – Temperature Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Sound_Sensor/[Grove – Sound Sensor^]
|1 |https://wiki.seeedstudio.com/Grove-Ultrasonic_Ranger/[Grove – Ultrasonic Ranger^]
|1 |https://wiki.seeedstudio.com/Grove-LED_Strip_Driver/[Grove – LED Strip Driver^]
|1 |https://wiki.seeedstudio.com/Grove-125KHz_RFID_Reader/[Grove - RFID Reader^]
|1 |https://www.dexterindustries.com/pivotpi/[PivotPi Board^]
|1 |https://www.raspberrypi.org/products/camera-module-v2/[Raspberry Pi Camera V2^]
|===

== Software
Nebst der verwendeten Hardware benötigen wir auch einige Software Bibliotheken zur Umsetzung unseres Projektes. Da der Simulator auf Java basieren soll, verwenden wir ausschliesslich Java Libraries zur Implementation der gewünschten Funktionalität.

=== Pi4J
Das Projekt Pi4J bietet Vollzugriff auf die I/O Funktionalität des Raspberry Pi über eine objektorientierte Java API. Die Bibliothek abstrahiert die komplexe Hardware Programmierung und ermöglicht es Java Programmieren, sich auf die Implementation ihrer eigenen Logik zu konzentrieren. <<Pi4J>>

* Exportieren und Importieren von GPIO Pins
* Konfigurieren der GPIO Pin-Flussrichtung
* Lesen und Schreiben des GPIO Pin State
* Pulse Width Modulation (Hardware & Software)
* Erstellen von GPIO State Listeners (Hardware Interrupt)
* Automatisches Setzen eines Pin State bei Programmende (GPIO Shutdown)
* Senden und Empfangen von Daten via serielle Schnittstelle (RS232)
* Support für Kommunikation über den I2C Bus (Inter-Integrated Circuit)
* Support für Kommunikation über den SPI Bus (Serial Peripheral Interface)
* Erweiterbarer GPIO Provider mit Support für GPIO Extension Boards
* Zugriff auf System- und Netzwerkinformationen des Raspberry Pi
* Wrapper Klassen für den direkten Zugriff auf WiringPi

Zu Projektstart war geplant, dass wir für unser Projekt die Pi4J Bibliothek in der aktuellsten Snapshot Version 1.4 verwenden werden, welche sich derzeit noch in der Entwicklungsphase befindet. Basis für diesen Entscheid war die Tatsache, dass Pi4J 1.4 Java 11 unterstützt. Die release Version 1.2 unterstützt lediglich Java 8 und ist deshalb weniger interessant. Im Verlauf unseres Projekts mussten wir diesen Entscheid jedoch überdenken. Es hat sich herausgestellt, dass der aktuelle Stand von Pi4J 1.4 nicht die gewünschte Stabilität für unser Projekt bieten kann. Dies zeigte sich während der Erarbeitung unserer Code Beispiele für den I2C LC-Display. Während der Entwicklung sind wir auf Probleme gestossen, welche direkt mit der Pi4J Version in Verbindung gebracht werden konnten. Die I2C Schnittstelle wird in Kombination mit Java 11 nicht unterstützt. Zu diesem Problem gibt es bereits ein offenes GibHub Issue auf dem Pi4J Projekt, welches als Workaround ein Downgrade auf Java 8 vorschlägt. Grundsätzlich war es aber das Ziel, durch den Einsatz von Pi4J 1.4 Java 8 zu vermeiden. Zusätzlich sind die Device Klassen, welche ein einfaches Interface für die Ansteuerung einer Vielzahl von Sensoren und Aktuatoren erlaubt, in Pi4J 1.4 nicht mehr enthalten. Diese wurden von den Entwicklern aus dem Projekt entfernt, da die Device Implementation kaum von Anwendern benutzt wurden. Für den GPIO Simulator sind diese Implementationen allerdings sehr interessant. Sie vereinfachen die Ansteuerung der Hardwarekomponenten und sind somit bestens für Studenten in den ersten Semestern geeignet.

Die Tatsache, dass in Pi4J 1.4 die Device Klassen fehlen und Java 11 wohl doch noch nicht komplett unterstütz wird, hat uns dazu bewegt, dass wir für unser Projekt auf die aktuelle Release Version 1.2 zurückgreifen.

=== Java
Ursprünglich wollten wir für unser Projekt Java 11 verwenden. Aus Kompatibilitätsgründen mit Pi4J 1.2 setzen wir nun Java 8 als Basis ein.

=== Gradle
Um unser Projekt auf dem Raspberry Pi oder dem Computer zu bauen, verwenden wir das Build Management Tool Gradle in der Version 6.5.1. Die Konfiguration des Builds wird über das File `build.gradle` realisiert. Anschliessend kann das Projekt via Konsole gebaut werden.

=== Log4j 2
Die Log Funktionalität ist für unser Produkt essenziell. Die Umsetzung des Loggings ist Bestandteil des Minimum Viable Product. Ziel ist es, dass alle Interaktionen mit den GPIO Pins und Grove Adaptern in einem geeigneten Format geloggt werden. Für Java stehen bereits diverse Logging Frameworks zur Verfügung. Ein weit verbreiteter und beliebter Vertreter ist Log4j 2 von Apache. Es bietet beispielsweise die Funktionalität, Logs in eine Rolling File zu schreiben. Ein solches File eignet sich hervorragen für unsere Zwecke, weshalb wir uns für die Verwendung dieses Frameworks entschieden haben. Des Weiteren kann Log4j 2 über ein XML File jederzeit konfiguriert werden, was ein weiterer Pluspunkt ist.

== Analyse Applikationsdesign
Durch die Ergebnisse der Anforderungsanalyse haben wir viele neue Erkenntnisse gewonnen. Diese Erkenntnisse bilden die Basis für designtechnische Entscheidungen, welche wir in diesem Kapitel festhalten.

=== Benutzeroberfläche
Ein wichtiger Entscheid, welcher in diesem Projekt getroffen werden muss, ist die Integrationsart der Benutzeroberfläche des Simulators. Unsere Analyse hat gezeigt, dass es zwei verschiedene Möglichkeiten gibt, wie das User Interface mit dem Backend des Simulators verbunden werden kann. Einerseits können wir den Simulator als Stand-Alone Applikation zur Verfügung stellen, andererseits könnte der Simulator auch direkt als Dependance in das Projekt der Anwender inkludiert werden. Beide Vorgehensweisen sind im Kern gleich, haben aber ihre jeweiligen Vor- und Nachteile, auf welche wir in dieser Dokumentation weiter eingehen.

==== Integration als Dependency
Bei diesem Integrationstyp wird der komplette Simulator zu einem festen Bestandteil des Raspberry Pi GPIO Projekts des Anwenders. Das Projekt beinhaltet nebst dem vom Anwender geschriebenen Code, welcher schlussendlich auf dem Raspberry Pi ausgeführt werden soll, zusätzlich das gesamte User Interface des Simulators. Dies führt dazu, dass das Projekt des Anwenders um einiges grösser wird. Allerdings würde uns die direkte Integration des Simulators als `.jar`-File unsere Arbeit erleichtern. Der Datenaustausch zwischen User Code und UI könnte über die uns bereits aus dem Unterricht bekannten UI Bindings von JavaFX implementiert werden. Des Weiteren gibt uns die Integration des Simulators in das Projekt des Anwenders mehr Freiheit bezüglich der Konfiguration des Simulators. Einerseits könnte das User Interface direkt aus dem Code des Anwenders generiert werden, andererseits könnte die Konfiguration der GPIO Schnittstellen auch im Simulator selbst erfolgen.

[.underline]#*Konfiguration via Code*#

Unter Verwendung dieser Konfigurationsart entscheidet der Code des Benutzers, welche Sensoren und Aktuatoren an welche virtuellen Anschlüsse des Simulators angeschlossen werden. Sobald der Benutzer den Code unter Verwendung des GPIO Simulators startet, generiert der Simulator das UI gemäss den im Code verwendeten Pins, Sensoren und Aktuatoren. Ein wesentlicher Vorteil dieses Konfigurationstyps ist sicher die Einfachheit der Anwendung. Der Benutzer muss sich lediglich um seinen Code kümmern. Genauso wie die Sensoren und Aktuatoren im Code verwendet werden, werden diese auch im Simulator angezeigt. Es ist somit ausgeschlossen, dass Pins verwendet werden, welche nicht mit Sensoren oder Aktuatoren verbunden sind. Dies kann aber auch ein Nachteil sein, da diese Konfigurationsart nicht wirklich der Realität entspricht, welche man in einem GPIO Projekt antrifft. Dort ist der Anwender für die Verkabelung der Sensoren und Aktuatoren mit dem Raspberry Pi selbst verantwortlich. Es kann durchaus passieren, dass beispielsweise die falschen Pins verbunden werden. Dieser Aspekt würde unter Verwendung der aus dem Code generierten Konfiguration verloren gehen.

.Dependency Integration mit Konfiguration im Code 
image::Dependency_Integration_Code.png[width=75% Design Dependecy]

[.underline]#*Konfiguration via Simulator*#

Bei diesem Konfigurationstyp wird die Konfiguration direkt im Simulator vorgenommen. Nachdem ein Anwender seinen Code ausführt, öffnet sich das UI des GPIO Simulators. Der Benutzer kann nun via Drag and Drop Sensoren und Aktuatoren im dafür vorgesehenen Bereich platzieren und diese mit den GPIO oder Grove Pins des virtuellen Grove Base Hat verbinden. Nachdem der Benutzer die Konfiguration abgeschlossen hat, kann er dies über einen Button bestätigen und die Simulation startet. Der Vorteil dieses Konfigurationstyps liegt ganz klar in der Realitätsnähe, welche über die Konfiguration via Code fehlt. Der Benutzer hat die Möglichkeit, Sensoren und Aktuatoren falsch anzuschliessen und muss dem Problem selbst auf den Grund gehen. Dies erhöht den Lerneffekt und trägt zum Verständnis bei. Nachteil ist allerdings, dass die Konfiguration erst nach dem Starten des Codes gemacht werden kann.

.Dependency Integration mit Konfiguration im Simulator
image::Dependency_Integration_Simulator.png[width=75% Design Dependecy]

==== Integration als Standalone Applikation
Bei diesem Integrationstyp wird der Simulator zu einer separaten Applikation, welche auf einem eigenen Prozess läuft. Der Code des Anwenders läuft während seiner Ausführung komplett unabhängig vom Simulator selbst. Die Unabhängigkeit der Projekte macht die Kommunikation zwischen den beiden Programmen komplizierter, da ein neuer, indirekter Weg für die Datenübertragung gefunden werden muss. Eine Standalone Applikation hätte aber den Vorteil, dass die Konfiguration des Simulators nicht erst zur Laufzeit stattfinden müsste. Man könnte den Simulator also starten und konfigurieren, ohne den Code bereits geschrieben zu haben. Ein Benutzer hätte die Möglichkeit, die Simulation zu starten und gegen den Simulator zu programmieren. Immer wenn der Anwender seinen Code ausführt, kann er direkt im Simulator sehen, ob der Code die gewünschte Wirkung hat. Der Entwickler bekommt also Echtzeit Feedback. Dieser Integrationstyp simuliert die Realität sicher am besten, da der Raspberry Pi auch eine separate Instanz ist, an welche, unabhängig von der Entwicklungsumgebung, die verschiedenen Sensoren und Aktuatoren angeschlossen werden können.

.Stand-Alone Integration 
image::Standalone_Integration.png[width=75% Design Standalone]

== GPIO Geräte kennenlernen
Bevor wir mit der eigentlichen Implementation des GPIO Simulators gestartet haben, machten wir uns mit einigen der uns zur Verfügung gestellten Hardware Komponenten bekannt. Durch die Umsetzung der einzelnen Beispiele konnten wir den Raspberry Pi besser kennenlernen und ein Verständnis dafür aufbauen, wie er über seine GPIO Pins mit Sensoren und Aktuatoren kommuniziert.

Total haben wir acht verschiedene Beispiele realisiert. Sie sind alle im Package fhnwexamples.gpio unseres Projektes zu finden.


=== LED
Die LED ist wohl für die meisten Programmiererinnen und Programmierer die erste Hardware Komponente, welche sie über einen GPIO Pin steuern. Auch für uns war die LED das erste Device, welches wir an den Raspberry Pi angeschlossen haben.

Eine LED kann direkt an einen GPIO Output Pin angeschlossen werden. In unserem Beispiel haben wir uns für den Pin 2 entschieden. Damit wir den Zustand der Leuchtdiode steuern können, müssen wir ein Objekt des Typen `GpioPinDigitalOutput` vom `GpioController` anfordern. Über dieses Objekt können wir den Zustand des Pins über die Funktionen `high()` und `low()` steuern. Unsere `BlinkLed` Klasse lässt die LED im Sekundentackt blinken.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/BlinkLed.java[tags=BlinkLed]
----

=== Button
Der Button ist das wohl einfachste Input Device überhaupt. Damit wir den aktuellen Wert des Buttons lesen können, benötigen wir einen `GpioPinDigitalInput`, welchen wir vom `GpioController` anfordern. Über die Funktionen `isHigh()` sowie `isLow()` können wir erfahren, ob der Button aktuell gedrückt ist oder nicht. In unserem Beispiel verwenden wir allerdings einen von Pi4J zur Verfügung gestellten Listener, welchen wir direkt auf dem Pin registrieren können. Bei Zustandsänderungen erhalten wir vom Listener sofort eine Benachrichtigung in Form eines Events. Dieses können wir dann auswerten.

Informationen zur Verkabelung des Buttons befinden sich im Tutorial.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/ButtonClick.java[tags=ButtonClick]
----

=== Key Pad
.Key Pad
[link=https://circuitdigest.com/microcontroller-projects/4x4-keypad-interfacing-with-pic16f877a]
image::keypad.png[width=75% Key Pad]

Ein Key Pad besteht im Prinzip aus einer Matrix von Buttons. In unserem Fall steuern wir ein 4x4 Key Pad an, welches aus 16 einzelnen Buttons besteht. Um zu erkennen, welcher Button im Moment gedrückt wird, benötigen wir acht GPIO Pins. Jeder dieser Pins repräsentiert eine Zeile oder eine Spalte in der oberen Grafik. Die Leiterbahnen X1 bis X4 haben wir als Output Pins deklariert. Die Pins Y1 bis Y4 sind unsere Input Pins. Beide legen wir als Array ab.

In einer for-Schleife setzen wir Zeile für Zeile unter Strom um prüfen dann pro Zeile, ob wir in einer der Spalten einen Input erhalten. Sollte dies der Fall sein, haben wir den aktuell gedrückten Knopf identifiziert und können ihn auf der Konsole ausgeben.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/KeyPad.java[tags=KeyPad]
----

=== LC-Display
Das von uns verwendet LC-Display erlaubt die Anzeige von je 16 Zeichen auf 2 Zeilen. Total können also 32 Zeilen angezeigt werden. LC-Displays gibt es in verschiedenen Varianten. Unser Display kann entweder über den I2C Bus des Raspberry Pis angesteuert werden oder auch direkt über die GPIO Pins. In diesem Beispiel verwenden wir die Kommunikation via GPIO Pins. Ein I2C Beispiel finden sie im Tutorial. <<>>

Das unten gezeigte Code Beispiel benutzt die `Lcd` Klasse von WiringPi. Im Konstruktor definieren wir, wie viele Zeilen und Spalten unser Display hat. In unserem Fall haben wir 2 Zeilen und 16 Spalten. Die Datenübermittlung erfolgt über 4 Bits. Mittels GPIO_01 bis GPIO_04 können wir Nachrichten an das Display senden. Über den RS Pin GPIO_06 wird dem Display mitgeteilt, ob es sich bei den gesendeten Bytes um einen Befehl oder um ein Zeichen handelt. Über den verbleibenden Pin GPIO_05 lässt sich die Helligkeit des Displays steuern.

Das Beispiel zeigt auf der ersten Zeile des Displays den Text "gpiosimulator" an. Auf der zweiten Zeile wird die aktuelle Uhrzeit angegeben.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/LcdSystemTime.java[tags=LcdSystemTime]
----

=== DC Motor
DC Motoren können auf verschiedene Arten gesteuert werden. Einerseits können wir die Drehgeschwindigkeit eines Motors über **P**ulse **W**idth **M**odulation steuern, andererseits können wir durch die Änderung der Polarität die Drehrichtung umkehren. Für letzteres benötigen wir aber weitere Hardware.

Informationen zur Hardware sowie dessen Verkabelung finden Sie im Tutorial.

==== Steuerung der Laufrichtung
Zur Steuerung der Laufrichtung benötigen wir einen Motor Driver. Für unser Beispiel haben wir den Treiber L293D verwendet. Mittels zwei Instanzen des `GpioDigitalOutputPin` können wir die Polarität des Treibers steuern. Ist der Pin `moveForward` HIGH und der Pin `moveBackward` LOW, dreht sich der Motor im Uhrzeigersinn. Kehrt man die Zustände der Pins um, so dreht der Motor im Gegenuhrzeigersinn. Wenn wir beide Pins LOW setzen, stoppt der Motor.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/MotorDirection.java[tags=MotorDirection]
----

==== Steuerung der Drehzahl
Die Drehzahl des Motors können wir über PWM steuern. Der Raspberry Pi bietet uns zwei getrennte PWM Schaltkreise, welche jeweils über zwei Pins verfügen. Mittels PWM kann ein Pin in einem gewünschten Rhythmus an- und ausgeschaltet werden. Über das sogenannte Puls-Pause Verhältnis wird definiert, wie viele Prozent der Pin pro Zyklus HIGH ist. Ein Puls-Pause Verhältnis oder Duty Cycle von 75% entspricht dabei einer HIGH Time von 75% gefolgt auf eine LOW Time von 25%.

.PWM als Grafik
[link=https://www.elektronik-kompendium.de/sites/kom/0401111.htm]
image::pwm.png[width=75% PWM as a Graph]

Das PWM Signal steuert also die Menge an Strom, welche zum Motor fliesst. Bei einem kleineren Duty Cycle fliesst weniger Strom pro Zeit. Bei einem grösseren Duty Cycle fliesst entsprechend mehr Strom. Dies beeinflusst die Drehzahl des Motors direkt, weshalb wir über PWM den Motor optimal steuern können.

Standardmässig entspricht ein PWM Wert von 1024 einer HIGH Time von 100%. Unser Beispiel lässt den Motor also in 10er Schritten von 0% bis 100% Drehleistung drehen.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/MotorSpeedHardPwm.java[tags=MotorSpeedHardPwm]
----

=== Serial Camera
Bei der Grove Serial Camera handelt es sich um eine über den UART Bus des Raspberry Pi steuerbare Kamera. Die Kommunikation zwischen Kamera und Raspberry Pi folgt dem OV528 Protokoll. Die Klasse `SerialCamera` im Package `fhnwexamples.gpio` stellt eine rudimentäre Implementation dieses Protokolls dar. Weitere Informationen zur Grove Serial Camera sowie dem Protokoll OV528 finden Sie im Kapitel _Zusatzinformationen_ im Tutorial. <<GroveCam>>

=== Servo Motor
Die Position des Armes eines Servo Motors lässt sich über ein PWM Signal steuern. Durch die Aufrechterhaltung eines konstanten Signals hält der Arm seine Position. Die meisten Servo Motoren benötigen einen PWM Input von 50Hz. Über die HIGH Time lässt sich der gewünschte Winkel einstellen. Wie wir bereits bei der Implementation der Drehzahlregulierung eines Gleichstrommotors gelernt haben, können wir die HIGH Time eines Pulses über den Duty Cycle regulieren. <<ServoMotor>>

In unserem Servo Motor Beispiel drehen wir den Arm schrittweise von 0 (550 Mikrosekunden) auf 180 (2600 Mikrosekunden) Grad. Ist der Motor bei seiner maximalen Position angekommen, setzen wir ihn wieder auf seine Ausgangsposition zurück.

[source,java]
----
include::{sourcedir}/fhnwexamples/gpio/ServoMotor.java[tags=ServoMotor]
----

=== Stepper Motor
Stepper Motoren lassen eine präzise Steuerung des Drehwinkels zu. Mit dem von uns eingesetzten Schrittmotor 28BYJ-48 können Drehungen auf 0.087890625° genau gemacht werden.

Unser Steppe Motor Beispiel verwendet das `GpioStepperMotorComponent` Objekt, welches Bestandteil des Component Package von Pi4J ist. Da dieses Package in zukünftigen Versionen von Pi4J nicht mehr enthalten sein wird, sparen wir uns an dieser Stelle die Beschreibung des Codes.

Die von uns im Rahmen des Tutorials implementierte Component Klasse zur Steuerung von Stepper Motoren ist bereits unter _Zusatzinformationen_ des Tutorials dokumentiert.

== Simulationsstrategie: 1. Iteration
Nebst der Frage, wie der Simulator in das GPIO Projekt des Studierenden integriert werden soll, müssen wir uns darüber Gedanken machen, wie wir den Wechsel zwischen Simulator und Hardware für den Benutzer möglichst einfach gestalten können. Grundsätzlich verfolgen wir das Ziel, dass der Benutzer den Code nur an einer einzigen Stelle ändern muss, um zwischen Simulator und Hardware zu switchen. Auch denkbar wäre eine Konfigurationsmöglichkeit ausserhalb des Codes mittels Konfigurationsdatei im XML oder JSON Format.

=== Erste Idee
Während der Analysephase haben wir geplant, das Factory Design Pattern für den Wechsel zwischen dem Simulator und der physischen Hardware zu verwenden. Pi4J implementiert nämlich selbst das Factory Pattern, was wir uns zu Nutzen machen möchten. In einem GPIO Projekt mit Pi4J muss als erstes immer die gewünschte Factory instanziiert werden, mit welcher die Pins angesteuert werden sollen. Zum Beispiel die GpioFactory, die I2CFactory oder die SerialFactory. Unsere Idee besteht darin, eine weitere Factory zur Verfügung zu stellen. Die GpioSimulatorFactory.

.Simulator Factory
image::GpioSimulatorFactory_Idee.png[500, 500, Factory Idee]

Damit wir das Factory Pattern von Pi4J wie geplant erweitern können, hätten wir eine Globale Factory implementieren müssen, von welcher sowohl Pi4J als auch unser Simulator erbt. Im oben abgebildeten Diagramm wird diese Factory durch die Klasse `GpioSimulatorFactory` verkörpert. Leider hat sich diese Vorgehensweise nicht bewährt, da wir die Klassen in Pi4J nicht bearbeiten können. Dies wäre aber bei einem Factory Pattern von Nöten, da die Subklassen von ihrem Parent, der Factory, erben müssen.

Um das Problem mit der Bearbeitung des Codes innerhalb von Pi4J zu umgehen, hätten wir einen Fork des GitHub Projektes machen können. Auf diesem Fork könnten wir dann die nötigen Anpassungen an den Klassen von Pi4J problemlos vornehmen. Wir hätten somit eine FHNW-Version der offiziellen Pi4J Bibliothek. Diese Vorgehensweise würde allerdings einen sehr grossen initialen Aufwand bedeuten, was den Rahmen unseres IP 5 Projektes sprengen würde. Des Weiteren müsste der gesamte Code in Zukunft von der FHNW gewartet und modern gehalten werden, was wohl nicht dem Ziel dieses Projektes entspricht.

=== Analyse Pi4J
Da eine FHNW-Version von Pi4J nicht in Frage kommt, müssen wir eine andere Möglichkeit finden, wie wir den GPIO Simulator implementieren können. In einem ersten Schritt gilt es, die Funktionalität und den Aufbau des gesamten Pi4J Pakets zu analysieren. Durch die Untersuchung möchten wir zusätzliche Erkenntnisse gewinnen, welche uns auf neue Ideen für mögliche Simulationsstrategien bringen.

Das Projekt Pi4J ist aufgeteilt in:

. *pi4j-core*: +
Stellt alle Klassen und Methoden zur Verfügung, um direkt auf die GPIO Pins zuzugreifen. 
. *pi4j-device*: +
Ist ein Abstraktionsschicht, welche die Nutzung von Sensoren und Aktuatoren vereinfacht, indem eigene Klassen zur Verfügung gestellt werden.
. *pi4j-distribution*: +
Enthält Scripts und Dateien, welche man für die Installation und Deinstallation benötigt.
. *pi4j-example*: + 
Enthält Beispiele für verschiedene Devices, die mit Pi4J angesteuert werden können.
. *pi4j-gpio-extension*: +
Enthält Software für die erleichterte Verwendung von Extension Boards wie z.B PiFace.
. *pi4j-native*: +
Enthält native Scripts für weitere Entwicklungsboards wie NanoPi oder BananaPi.

In unserem Projekt benötigen wir ausschliesslich die ersten beiden Projekte. pi4j-core und pi4j-device. Alle weiteren Bestandteile von Pi4J benötigen wir nicht.

=== Mögliche Vorgehensweisen
Auf Basis unserer Analyse gilt es eine Entscheidung zu treffen, wie wir den Switch zwischen Simulator uns Hardware technisch umsetzen möchten. Wir haben uns zusammen mit unseren Projektpartnern auf die folgenden drei Möglichkeiten geeinigt.

=== Simulator = Tutorial
Bei dieser Vorgehensweise entfällt der Simulator Aspekt unseres Projektes. Das Ziel unserer Arbeit wäre es nicht mehr, einen Simulator für Sensoren und Aktuatoren auf Basis von Pi4J zu implementieren. Das neue Ziel wäre das zur Verfügung stellen einer Abstraktionsstufe für Sensor- und Aktuator-Zugriffe, welche durch ein informatives Tutorial begleitet werden. Der Fokus des Projektes liege dann in der Unterstützung von Studentinnen und Studenten im ersten Semester bei der Umsetzung ihrer GPIO Projekte durch die von uns gesammelten Erfahrungen.

Wenn wir uns für diese Vorgehensweise entscheiden, müssen wir für die wichtigsten uns zur Verfügung gestellten Sensoren und Aktoren Abstraktionen sowie Beispiele ausarbeiten, welche den Studierenden als direkte Referenz dienen können. Durch das zur Verfügung stellen von guten, konkreter Code Beispielen müssen sich die Studentinnen und Studenten weniger mit der Hardware beschäftigen und können somit besser am Code und der Funktionalität ihres Projektes arbeiten.

=== Simulator auf Ebene GPIO
Bei dieser Vorgehensweise würden wir das Ziel verfolgen, alle Funktionen von Pi4J-Core simulieren zu können. Da Pi4J-Core der Kern von Pi4J ist und dieses Paket direkt mit den GPIO Pins arbeitet, bieten sich die GPIO Pins als geeignete Docking-Station für unseren Simulator an. Wenn wir die GPIO Pins simulieren können, so könnten wir letztlich sämtliche GPIO Befehle simulieren. Diese Vorgehensweise würde im Effekt die Simulation von sämtlichen Projekten unterstützen.

Allerdings erachten wir die Simulation auf dieser Ebene als schwierig umzusetzen. Die Schwierigkeit bestünde hauptsächlich im Umfang der Pi4J-Core Library. Die Bibliothek ist sehr gross und es ist für uns unvorhersehbar, welche Bereiche wirklich von den Studenten benötigt werden würden. Selbst bei der Verwendung eines einfachen Buttons dringt man beim Debuggen sehr schnell in die Tiefen von Pi4J ein und landet in diversen weiteren Libraries, welche im Projekt inkludiert sind.  Beispielsweise wird für manche Geräte WiringPi benötigt. WiringPi ist eine native Library, welche in Pi4J inkludiert ist.

Eine Simulation auf GPIO Ebene würde dazu führen, dass der Simulator sehr umfangreich wäre und ein höheres Risiko bestünde, dass die Menge der Arbeit im Backend exponentiell zunehmen könnte. Es wäre durchaus möglich, dass dies zu einem enormen Zeitverlust in der Arbeit am Backend führen könnte. Daraus folgt, dass die Arbeit an der Usability und die Arbeit an der Benutzeroberfläche zu kurz kommt oder kaum begonnen werden kann.

Wenn wir uns für dieses Vorgehen entscheiden, müssen wir damit rechnen, dass das Projekt womöglich bis zur Deadline nicht im gewünschten Status ist.

=== Simulator auf Ebene Device
Bei dieser Vorgehensweise würden wir das Ziel verfolgen, alle Funktionen von Pi4J-Device simulieren zu können. Der Umfang des Pi4J-Device Layer ist definitiv überschaubarer im Vergleich zu jenem vom Pi4J-Core. Pi4J-Device bietet direkt Klassen für einzelne Devices an, welche die nötigen GPIO Zugriffe abstrahieren.

Ansetzen würden wir bei dieser Implementationsart direkt bei den Device Beispielen von Pi4J. Für die oft verwendeten Devices würden wir eigene Klassen implementieren, welche die Simulation der Hardware übernehmen. Die Studentinnen und Studenten könnten in ihrem Code wählen, welches Device sie verwenden möchten. Entweder das simulierte Device oder das Pi4J-Device, welches direkt auf die Hardware zugreift. Dies hätte für uns den Vorteil, dass die Arbeit im Backend im Vergleich zur Simulation der GPIO Pins wesentlich geringer wäre und weniger Risiken mit sich bringen würde.

Leider haben wir während unseren Recherchen festgestellt, dass Pi4J-Device in zukünftigen Releases nicht mehr weitergeführt wird. Aus diesem Grund bräuchte man eine eigene Pi4J-Device Version, welche dann von der FHNW weitergeführt und ergänzt werden könnte, wenn beispielsweise neue Devices benötigt werden.

Wenn wir uns für dieses Vorgehen entscheiden, brauchen wir also eine eigene FHNW-Version von Pi4J Device, welche weitergeführt und gewartet werden muss.

=== Entscheidung
Letztendlich haben wir uns für die Simulation auf Ebene von Pi4J-Device entschieden, da das Risiko und der Umfang der Simulation der GPIO Pins schlicht und einfach zu unvorhersehbar gewesen wäre. Der Tutorial-Aspekt des Projektes geht dabei auch nicht verloren, da wir für alle Geräte drei Beispiele machen werden:

. Ein Beispiel, welches direkt mit den GPIO Pins arbeitet.
. Ein Beispiel, welches die Pi4J-Device Klasse des Geräts verwendet.
. Ein Beispiel, welches den GPIO-Simulator verwendet.

Anhand der zur Verfügung gestellten Beispielen können sich die angehenden Studentinnen und Studenten bestens für die von Ihnen präferierte Vorgehensweise entscheiden und Ihr Projekt entsprechend umsetzen. Durch das Studieren des Beispielcodes lernen die Studierenden sicherlich vieles dazu, was ihnen später bei der Implementierung von Nutzen sein wird.

== Simulationsstrategie: 2. Iteration
Während der Arbeit am Simulator auf Basis von Pi4J-Device sind wir nach einiger Zeit auf neue Hindernisse gestossen, welche sich als unüberwindbar herausgestellt haben. Deshalb mussten wir unser Vorgehen erneut überdenken.

=== Problembeschreibung
Um die Devices simulieren zu können, haben wir eine Factory erstellt, welche im Konstruktor einen Boolean annimmt. Dieser Boolean bestimmt, welcher Typ von Device zurückgegeben wird. Entweder ein Pi4J-Device oder unser Custom Simulator Device. Der untere Java Code zeigt einen solchen Konstruktor für das LED Device.

[source,java]
----
public LEDBase getLED(GpioPinDigitalOutput pin) {
    LEDBase led = simulator ? new GpioLEDSimulator(pin) : new GpioLEDComponent(pin);
    return led;
}
----

Das Simulator LED Device unterstützt im Moment lediglich die Funktion `blink()`, welche wiederum die Funktionen `on()` und `off()` aufrufen. In den beiden letzteren Funktionen haben wir jeweils einfach den aktuellen Status mittels Log4j 2 auf die Konsole sowie in ein Rolling File geschrieben.

[source,java]
----
@Override
public Future<?> blink(long delay) {
    return executor.submit(() -> {
        while (true) {
            if (isOn())
                off();
            else
                on();
            Thread.sleep(delay);
        }
    });
}
----

Um unsere Implementation zu testen, haben wir die von uns geschriebene Klasse `BlinkLedDevice` so modifiziert, dass wir eine `LEDBase` vom Typ `GpioLEDSimulator` erhalten. Dies haben wir durch den im Konstruktor der Factory übergebenen Boolean festgelegt. Auf dem Simulator Device rufen wir nun die `blink()` Funktion auf.

[source,java]
----
public class BlinkLedDevice extends Example {

    public BlinkLedDevice(int key, String title) {
        super(key, title);
    }

    @Override
    public void execute() throws Exception {
        GpioFactory.setDefaultProvider(new RaspiGpioProvider(RaspiPinNumberingScheme.BROADCOM_PIN_NUMBERING));
        final GpioController gpio = GpioFactory.getInstance();

        GpioPinDigitalOutput led = gpio.provisionDigitalOutputPin(RaspiBcmPin.GPIO_02, "Blinking LED" , PinState.LOW);
        led.setShutdownOptions(true, PinState.LOW);
        
        // new GpioSimulatorFactory(true) => Is a Simulator Factory
        GpioSimulatorFactory gpioSimulatorFactory = new GpioSimulatorFactory(true);
        LEDBase ledComponent = gpioSimulatorFactory.getLED(led);

        Console console = new Console();
        console.promptForExit();

        long delay = 1000;
        console.println("start blinking with "+delay+" delay");

        ledComponent.blink(delay);

        gpio.shutdown();
    }
}
----

Beim Testen unseres Codes mussten wir allerdings feststellen, dass diverse Pi4J Aufrufe nicht funktionieren, welche für die Ausführung des Codes auf dem Raspberry Pi allerdings immer von Nöten sein werden. Beispielsweise ist es uns nicht möglich, über die statische Klasse `GpioFactory` den Default-Provider zu setzen, wenn wir als Provider den `RaspiGpioProvider` verwenden. Dieser greift in seinen Tiefen auf WiringPi zu. WiringPi erwartet dann gewisse Files an einem bestimmten Ort auf einem Linux Dateisystem. Diesen Pfad findet er auf einem Windows Rechner natürlich nicht und wirft deshalb bei der Ausführung des Codes folgende Fehlermeldung:

[source]
----
SCHWERWIEGEND: Unable to load [libpi4j.so] using path: [/lib/raspberrypi/dynamic/libpi4j.so]
java.lang.IllegalArgumentException: The path has to be absolute, but found: \lib\raspberrypi\dynamic\libpi4j.so
----

Wenn wir unseren Code im Simulator Modus auf dem Raspberry Pi laufen lassen, funktioniert die Simulation problemlos. Wir erhalten dann den gewünschten Log.

[source]
----
10:16:37.993 [pool-2-thread-1] INFO  gpiosimulator.GpioSimulatorFactory - LED is on
10:16:38.996 [pool-2-thread-1] INFO  gpiosimulator.GpioSimulatorFactory - LED is off
10:16:39.997 [pool-2-thread-1] INFO  gpiosimulator.GpioSimulatorFactory - LED is on
10:16:40.999 [pool-2-thread-1] INFO  gpiosimulator.GpioSimulatorFactory - LED is off
10:16:42.000 [pool-2-thread-1] INFO  gpiosimulator.GpioSimulatorFactory - LED is on
----

Ein möglicher Workaround wäre es, einen anderen Provider anstelle des `RaspiGpioProvider` zu verwenden. Pi4J stellt nämlich auch einen `SimulatedGpioProvider` zur Verfügung.

[source,java]
----
GpioFactory.setDefaultProvider(new SimulatedGpioProvider());
----

Momentan wissen wir, dass dieser Provider das gleiche Interface implementiert wie der `RaspiGpioProvider`. Allerdings retourinert er überall einfach null oder löst bestimmte Events schlicht nicht aus. Wenn wir diesen Provider in einem unserer GPIO Beispiele verwenden, passiert schlichtweg nichts.

Wir haben uns über das weitere Vorgehen Gedanken gemacht und uns überlegt, wie wir das Projekt dennoch gewinnbringend weiterführen können.

=== SimulatedGpioProvider verwerden
Generell gehen wir davon aus, dass wir unter Verwendung des `SimulatedGpioProvider` den Simulator wie geplant implementieren können. Der Benutzer müsste seinen Code jedoch nicht nur an einer Stelle anpassen, sondern an mindestens zwei Stellen. Das wäre aber wohl noch verkraftbar.

Durch unsere bisherig gesammelten Erfahrungen mit den Sensoren und Aktuatoren sind wir uns aber unsicher, wie viel eine Simulation dem Studenten schlussendlich überhaupt an Mehrwert bringt. Wenn wir beispielsweise ein I2C LCD simulieren würden, könnten wir lediglich den Text an einem bestimmten Ort (Konsole / File / Simulator) weitergeben und anzeigen. Ob nun die Verkabelung stimmt und der Text in die richtigen Bytes zerlegt wird, können wir kaum testen oder sicherstellen, da dafür die Logik des Mikrochips auf dem Gerät auch im Simulator simuliert werden müsste. Dies trifft nicht nur für das LCD zu, sondern für die meisten Sensoren und Aktuatoren. Bei einigen Geräten, wie dem Ultrasonic Ranger, muss die Zeit zwischen Emission und Rezeption der Ultraschallwelle in Mikrosekunden gemessen werden, was sehr stark von dem Gerät selber und der Umgebung abhängt. Eine Simulation könnte zufällige Zahlen zurückgeben, aber das würde dem Studierenden nicht helfen, da man erst wirklich sehen kann, ob die Berechnung korrekt ist, wenn man es mit der richtigen Hardware testet. In all diesen Fällen wäre ein Simulationsversuch reine Zeitverschwendung.

=== Der Simulator wird zum ausführlichen Tutorial
Diesen Ansatz haben wir bereits besprochen. Resultat der Projektarbeit wären eine Art Guide für die Verwendung von Pi4J-Devices, welche wir mit unseren eigen FHNW-Devices ergänzen können. Zusätzlich würden wir noch den Grove Hat und dessen Adapter unterstützen. Wir bieten dem Studenten somit stabile Beispiele, dessen Funktionsfähigkeit auf der verwendeten Hardware garantiert werden kann. Unserer Meinung nach wäre dieser Ansatz wesentlich gewinnbringender für die Studierenden als eine oberflächliche Simulation. Die schwierige Arbeit bei einem GPIO Projekt hängt nämlich immer von der verwendeten Hardware ab.

=== Entscheidung
Gemeinsam mit unseren Coaches haben wir uns dafür entschieden, ein ausführliches Tutorial zu schreiben. Dieses ist schlussendlich erfolgsversprechender und bietet den Studierenden einen grösseren Nutzen als ein Simulator.

Das Tutorial soll ein separates Dokument sein und muss am Anfang ein Setup Guide für den Raspberry Pi enthalten. Alternativ kann auch ein Image für die angehenden Studenten zur Verfügung gestellt werden, um das Setup noch weiter zu erleichtern.

Bei den Code Beispielen muss ausserdem darauf geachtet werden, dass sie nicht zu komplexe Themen wie Asynchronität ansprechen, da solche Themen den Rahmen eines Projektes für das erste und zweite Semester sprengen würden.

== Projektstrategie: Tutorial
Das Ziel des Tutorials soll es sein, die primäre Anlaufstelle für Hilfestellungen bezüglich der meistverwendeten Sensoren und Aktuatoren zu sein. Zudem sollte genau erklärt werden, wie ein GPIO Projekt in Java eingerichtet wird und wie die Component Klassen als API eingebunden werden können.

Um diesen Anforderungen gerecht zu werden, ist das Tutorial aus den folgenden Teilen zusammengesetzt.

* *Allgemeine Beschreibung:* +
Im ersten Teil wird das Ziel des Tutorials und die verwendete Hardware beschrieben. Der Leser soll verstehen, womit in den darauffolgenden Kapiteln gearbeitet wird. Der Raspberry Pi, das Grove System mit den Grove Sensoren und Aktuatoren, sowie die verschiedenen Verbindungsmöglichkeiten der Geräte sollen an dieser Stelle erklärt werden.

* *Setup des Raspberry Pi:* +
In diesem Teil wird aufgezeigt, wie der Raspberry Pi aufgesetzt werden kann, damit GPIO Projekte mit ihm realisiert werden können. Es soll ein möglichst benutzerfreundliches Setup für die Entwicklung gefunden werden. Die Einrichtung soll detailliert beschrieben werden und muss einfach nachvollziehbar sein. Des Weiteren muss ersichtlich sein, wie man den Code auf dem Pi bauen und ausführen kann.

* *Komponentenklassen:* +
In diesem Teil werden alle Sensoren und Aktuatoren beschrieben, für welche eine Component Klasse in Java geschrieben wurde. Jede von uns unterstützte Komponente soll in die folgenden Unterkapitel aufgeteilt werden:
** Eine grobe Beschreibung des Geräts, welches kurz auf den Aufbau und die Funktionsweise eingeht.
** Die Verkabelung an dem Breadboard oder dem Grove Base Hat soll anhand eines Fritzings oder eines Bildes gezeigt werden.
** Die Konstruktoren und öffentlichen Methoden der Komponentenklasse sollen in einer API-Tabelle dokumentiert sein.
** Zuletzt soll anhand eines Anwendungsbeispiels gezeigt werden, wie eine solche Komponentenklasse aufgerufen und verwendet werden kann.

* *Beispielprojekt:* +
In diesem Teil wird ein Beispielprojekt definiert, in welchem verschiedene Komponenten verwendet werden und miteinander zusammenspielen.
Das Ziel des Beispielprojektes ist es zu zeigen, wie von Grund auf ein neues Java GPIO Projekt aufgesetzt werden kann und wie man in einem solchen Projekt die Component Klassen als API einbindet und verwendet.

Das Beispielprojekt soll auch zeigen, wie das Logging der Component Klassen eingesetzt wird und wie ein neues Projekte auf dem Raspberry Pi mit Gradle gebaut werden kann.

* *Zusatzinformationen:* +
Dieser Teil dient als Ergänzung zum Allgemeinen Teil der Komponenten. Im vorherigen Abschnitt werden die Komponenten als Blackbox beschrieben und es wird gezeigt, wie man die API verwenden kann. In diesem Abschnitt wird zusätzlich erklärt, was im Hintergrund tatsächlich passiert und wie wir die verschiedenen Protokolle und Funktionen der Components implementiert haben. Für Studierende, welche mehr über die Geräte und den Code der Komponenten erfahren möchten, bietet dieses Kapitel eine sinnvolle Zusatzlektüre. Auch bei Problemen oder Fragen lohnt es sich, zuerst diesen Teil zu durchforsten.

== Fazit
Während der Umsetzung unserer Projektarbeit stand stets der Nutzen des Endproduktes im Fokus. Mit unserem Deliverable möchten wir die Studierenden in den Projekten 1 und 2 möglichst gut bei ihrem Einstieg in die Programmierung mit dem Raspberry Pi und Java unterstützen. Während der Arbeit an unserem Projekt wurden wir immer wieder aufs Neue mit unterschiedlichen Hindernissen konfrontiert, welche es zu überwinden galt. Um die Stolpersteine erfolgreich umschiffen zu können, mussten wir unsere Flexibilität unter Beweis stellen. 

Obschon der geplante Hardware Simulator im Rahmen dieses Projektes nicht umgesetzt werden konnte, erfüllt unser Resultat dennoch das uns gestellte Hauptziel. Wir sind davon überzeugt, dass wir den Studierenden durch unser Tutorial und die darin enthaltenen Beispielen einen reibungslosen Einstieg in die Welt der GPIO Programmierung mit dem Raspberry Pi und Java ermöglichen. Die durch uns entwickelten Component Klassen abstrahieren die teils sehr komplexen Abläufe und Hardware Protokolle von verschiedenen Komponenten und stellen stattdessen Klassen und Funktionen zur Verfügung, welche ohne weitere Detailkenntnisse verwendet werden können. Die Studierenden müssen sich nicht mehr mit der dahintersteckenden Elektronik auseinandersetzen, wenn sie dies nicht wollen. Im Teil _Zusatzinformationen_ unseres Tutorials finden interessierte Studentinnen und Studenten dennoch weiterführende Informationen zu unseren Komponenten sowie zur Funktionalität und dem Aufbau des jeweiligen Sensors oder Aktuators.

Beim Implementieren unseres GPIO Beispielprojektes hatten wir selbst die Möglichkeit, uns von der Nützlichkeit unseres Tutorials und den entwickelten Component Klassen zu überzeugen. Durch die Verwendung Library konnten wir in weniger als eineinhalb Stunden eine vollständig funktionsfähige Fotokabine mit sieben externen Hardware Komponenten implementieren. Ein solches Projekt würde ohne die vorgefertigten Component Klassen bestimmt mehrere Tage in Anspruch nehmen. Für uns ein klarer Erfolg!

Im Verlauf des Projektes haben wir viele spannende neue Erkenntnisse gesammelt, von denen wir in Zukunft bestimmt profitieren können. Die Arbeit am GPIO Simulator sowie dem daraus resultierenden Tutorial mit Anwendungsbeispielen hat uns stets Freude bereitet. Das Arbeiten im Projektteam war zu jeder Zeit von einer angenehmen Atmosphäre geprägt und zielgerichtet. Wir sind mit dem Resultat zufrieden und freuen uns auf dessen Einsatz in den GPIO Projekten der Studierenden im kommenden IP1/2.

:sectnums!:
[bibliography]
== Literaturverzeichnis
- [[[LCD,1]]] Arduino-Grundlagen: LCD ansteuern [https://rotering-net.de/tut/arduino/lcd-ansteuern.html, 10.08.2020]

- [[[GroveCam,2]]] Seed Studio: Grove - Serial Camera Kit [https://wiki.seeedstudio.com/Grove-Serial_Camera_Kit/, 10.08.2020]

- [[[Pi4J,3]]] The Pi4J Project: Welcome to Pi4J! [https://www.pi4j.com/1.2/index.html, 10.08.2020]

- [[[ServoMotor,4]]] Youtube - Daniel Ross: Java and Raspberry Pi Programming - Servo Control Explained [https://www.youtube.com/watch?v=xw10KuDYu4Q, 10.08.2020]

== Ehrlichkeitserklärung
Die Autoren Anessollah Ima und Jonathan Bättig erklären hiermit, dass wir die vorliegende Arbeit eigenständig und ohne unerlaubte fremde Hilfe erstellt haben. Alle Textstellen in der Arbeit, die wörtlich oder sinngemäss aus Quellen entnommen wurden, haben wir als solche gekennzeichnet und im Literaturverzeichnis angegeben.

== Anhang
* Projektvereinbarung
* Tutorial
* Projekt auf GitHub: https://github.com/FHNW-IP5-IP6/GPIOSimulator
* Release auf GitHub: https://github.com/FHNW-IP5-IP6/GPIOSimulator/releases/